<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>golang 中 slice 和 array 的区别</title>
    <url>/2021/02/01/golang-array-vs-slice/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><table>
<thead>
<tr>
<th>Array</th>
<th>Slice</th>
</tr>
</thead>
<tbody><tr>
<td>底层是一段连续的内存空间</td>
<td>底层是一个指向数组的指针(数组指针)</td>
</tr>
<tr>
<td>只有len属性, 且长度固定</td>
<td>有len和cap属性, 且不固定</td>
</tr>
<tr>
<td>Go数组是值类型, 赋值和函数传参操作都会复制整个数组数据</td>
<td>引用类型</td>
</tr>
</tbody></table>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="大数组传参"><a href="#大数组传参" class="headerlink" title="大数组传参"></a>大数组传参</h3><p>一个大数组传递给函数会消耗很多内存，采用切片的方式传参可以避免上述问题。<br>切片是引用传递，所以它们不需要使用额外的内存并且比使用数组更有效率。</p>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p><strong>测试代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">array</span><span class="params">()</span> [<span class="title">SIZE</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x [SIZE]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line">		x[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slice</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	x := <span class="built_in">make</span>([]<span class="keyword">int</span>, SIZE)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line">		x[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkArray</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		array()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSlice</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		slice()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果：</strong></p>
<blockquote>
<p>各个字段含义: 核数(4)，循环次数，平均每次执行时间，每次执行堆上分配内存总量，分配次数</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SIZE=100</span><br><span class="line">BenchmarkArray-4         3633415               312 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkSlice-4         2575620               499 ns/op             896 B/op          1 allocs/op</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SIZE=1000</span><br><span class="line">BenchmarkArray-4          437178              2835 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkSlice-4          304779              3781 ns/op            8192 B/op          1 allocs/op</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SIZE=10000</span><br><span class="line">BenchmarkArray-4           38402             27179 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkSlice-4           33938             36109 ns/op           81920 B/op          1 allocs/op</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SIZE=100000</span><br><span class="line">BenchmarkArray-4            3666            294832 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkSlice-4            2868            358106 ns/op          802818 B/op          1 allocs/op</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SIZE=1000000</span><br><span class="line">BenchmarkArray-4             213           5484479 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkSlice-4             358           3994363 ns/op         8003590 B/op          1 allocs/op</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SIZE=10000000</span><br><span class="line">BenchmarkArray-4               7         170413247 ns/op        80003074 B/op          1 allocs/op</span><br><span class="line">BenchmarkSlice-4              42          27718152 ns/op        80003080 B/op          1 allocs/op</span><br></pre></td></tr></table></figure>
<p>这样对比看来，并非所有时候都适合用切片代替数组，因为切片底层数组可能会在堆上分配内存，而且小数组在栈上拷贝的消耗也未必比 make 消耗大。</p>
<h3 id="Array-修改拷贝的值不影响原来的数组"><a href="#Array-修改拷贝的值不影响原来的数组" class="headerlink" title="Array 修改拷贝的值不影响原来的数组"></a>Array 修改拷贝的值不影响原来的数组</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">    b := a</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">    fmt.Println(a, b) <span class="comment">// [1 2 3 5 6] [10 2 3 5 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Slice-底层是数组指针-修改拷贝的值影响原来的切片"><a href="#Slice-底层是数组指针-修改拷贝的值影响原来的切片" class="headerlink" title="Slice 底层是数组指针, 修改拷贝的值影响原来的切片"></a>Slice 底层是数组指针, 修改拷贝的值影响原来的切片</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	b := a</span><br><span class="line">	b[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">	fmt.Println(a, b) <span class="comment">// [10 2 3 5 6] [10 2 3 5 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在cap不足时-append会返回新的切片"><a href="#在cap不足时-append会返回新的切片" class="headerlink" title="在cap不足时, append会返回新的切片"></a>在cap不足时, append会返回新的切片</h3><blockquote>
<p>当原来切片的cap小于1024时, 新切片的cap为原来的 2 倍<br>当原来切片的cap大于等于1024时, 新切片的cap为原来的 1.25 倍</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	b := a</span><br><span class="line">	b = <span class="built_in">append</span>(b, <span class="number">7</span>)</span><br><span class="line">	b[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">	fmt.Println(a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a)) <span class="comment">// [1 2 3 5 6] 5 5</span></span><br><span class="line">	fmt.Println(b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b)) <span class="comment">// [10 2 3 5 6 7] 6 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>golang</tag>
        <tag>array</tag>
        <tag>slice</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang三色标记、混合写屏障GC模式图文全分析</title>
    <url>/2021/01/28/golang-gc/</url>
    <content><![CDATA[<blockquote>
<p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。</p>
<p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the world)，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，Golang进行了多次的迭代优化来解决这个问题。</p>
</blockquote>
<h2 id="内容提纲"><a href="#内容提纲" class="headerlink" title="内容提纲"></a>内容提纲</h2><ul>
<li>G0 V1.3之前的标记-清除(mark and sweep)算法</li>
<li>Go V1.3之前的标记-清扫(mark and sweep)的缺点</li>
<li>Go V1.5的三色并发标记法</li>
<li>Go V1.5的三色标记为什么需要STW</li>
<li>Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )</li>
<li>Go V1.8混合写屏障机制</li>
<li>Go V1.8混合写屏障机制的全场景分析</li>
</ul>
<h2 id="一、Go-V1-3之前的标记-清除-mark-and-sweep-算法"><a href="#一、Go-V1-3之前的标记-清除-mark-and-sweep-算法" class="headerlink" title="一、Go V1.3之前的标记-清除(mark and sweep)算法"></a>一、Go V1.3之前的标记-清除(mark and sweep)算法</h2><p>此算法主要有两个主要的步骤：</p>
<ul>
<li>标记(Mark phase)</li>
<li>清除(Sweep phase)</li>
</ul>
<p><strong>第一步</strong> 暂停程序业务逻辑<br>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停，即<code>STW(stop the world)</code>。<br>也就是说，这段时间程序会卡在那儿。<br><img src="mas-1.png" alt="setp-1"></p>
<p><strong>第二步</strong> 开始标记，程序找出它所有可达的对象，并做上标记<br><img src="mas-2.png" alt="setp-2"></p>
<p><strong>第三步</strong> 标记完了之后，然后开始清除未标记的对象<br><img src="mas-3.png" alt="setp-3"></p>
<p><strong>第四步</strong> 停止暂停，让程序继续跑。<br>然后循环重复这个过程，直到process程序生命周期结束。</p>
<h2 id="二、标记-清扫-mark-and-sweep-的缺点"><a href="#二、标记-清扫-mark-and-sweep-的缺点" class="headerlink" title="二、标记-清扫(mark and sweep)的缺点"></a>二、标记-清扫(mark and sweep)的缺点</h2><ul>
<li><code>STW(stop the world)</code> 让程序暂停，程序出现卡顿 (<code>重要问题</code>)。</li>
<li>标记需要扫描整个heap</li>
<li>清除数据会产生heap碎片</li>
</ul>
<p>Go V1.3版本之前就是以上来实施的, 流程是<br><img src="mas-4.png" alt="before v1.3"></p>
<p>Go V1.3 做了简单的优化,将STW提前, 减少STW暂停的时间范围<br><img src="mas-5.png" alt="v1.3"></p>
<p><strong>这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序</strong></p>
<p>Go是如何面对并这个问题的呢？接下来Go V1.5版本 就用<code>三色并发标记法</code>来优化这个问题.</p>
<h2 id="三、Go-V1-5的三色并发标记法"><a href="#三、Go-V1-5的三色并发标记法" class="headerlink" title="三、Go V1.5的三色并发标记法"></a>三、Go V1.5的三色并发标记法</h2><p>三色标记法 实际上就是通过三个阶段的标记来确定清楚的对象都有哪些. 我们来看一下具体的过程.</p>
<p><strong>第一步</strong> 就是只要是新创建的对象, 默认的颜色都是标记为<code>白色</code>.<br><img src="tri-color-1.png" alt="setp-1-1"><br>这里面需要注意的是, 所谓<code>程序</code>, 则是一些对象的根节点集合.<br>所以上图,可以转换如下的方式来表示.<br><img src="tri-color-2.png" alt="setp-1-2"></p>
<p><strong>第二步</strong> 每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从<code>白色</code>集合放入<code>灰色</code>集合。<br><img src="tri-color-3.png" alt="setp-2-1"></p>
<p><strong>第三步</strong> 遍历<code>灰色</code>集合，将<code>灰色</code>对象引用的对象从<code>白色</code>集合放入<code>灰色</code>集合，之后将此<code>灰色</code>对象放入<code>黑色</code>集合<br><img src="tri-color-4.png" alt="setp-3-1"></p>
<p><strong>第四步</strong> 重复第三步, 直到<code>灰色</code>中无任何对象.<br><img src="tri-color-5.png" alt="setp-4-1"><br><img src="tri-color-6.png" alt="setp-4-2"></p>
<p><strong>第五步</strong> 回收所有的<code>白色</code>标记表的对象. 也就是回收垃圾.<br><img src="tri-color-7.png" alt="setp-5-1"></p>
<p>以上便是<code>三色并发标记法</code>, 不难看出,我们上面已经清楚的体现<code>三色</code>的特性, 那么又是如何实现<code>并行</code>的呢?<br>同时又是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p>
<h2 id="四、没有STW的三色标记法"><a href="#四、没有STW的三色标记法" class="headerlink" title="四、没有STW的三色标记法"></a>四、没有STW的三色标记法</h2><p>我们还是基于上述的<code>三色并发标记法</code>来说, 他是一定要依赖<code>STW</code>的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。</p>
<p>我们举一个场景, 如果<code>三色标记法</code>, 标记过程不使用<code>STW</code>将会发生什么事情?<br><img src="tri-no-stw-1.png" alt="tri-no-stw"><br><img src="tri-no-stw-2.png" alt="tri-no-stw"><br><img src="tri-no-stw-3.png" alt="tri-no-stw"><br><img src="tri-no-stw-4.png" alt="tri-no-stw"><br><img src="tri-no-stw-5.png" alt="tri-no-stw"></p>
<p>可以看出，有两个问题, 在三色标记法中,是不希望被发生的</p>
<ul>
<li>条件1: 一个<code>白色</code>对象被<code>黑色</code>对象引用(<strong><code>白色</code>被挂在<code>黑色</code>下</strong>)</li>
<li>条件2: <code>灰色</code>对象与它之间的可达关系的<code>白色</code>对象遭到破坏(<strong><code>灰色</code>同时丢了该<code>白色</code></strong>)<br>当以上两个条件同时满足时, 就会出现对象丢失现象!</li>
</ul>
<p>当然, 如果上述中的白色对象3, 如果他还有很多下游对象的话, 也会一并都清理掉!</p>
<p>为了防止这种现象的发生，最简单的方式就是<code>STW</code>，直接禁止掉其他用户程序对对象引用关系的干扰，<strong>但是<code>STW</code>的过程有明显的资源浪费，对所有的用户程序都有很大影响</strong>，如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少<code>STW</code>时间呢？</p>
<h2 id="五、屏障机制"><a href="#五、屏障机制" class="headerlink" title="五、屏障机制"></a>五、屏障机制</h2><p>我们让GC回收器,满足下面两种情况之一时,可保对象不丢失,所以引出两种方式.</p>
<h3 id="强-弱-三色不变式"><a href="#强-弱-三色不变式" class="headerlink" title="强-弱 三色不变式"></a>强-弱 三色不变式</h3><h4 id="强三色不变式-不存在黑色对象引用到白色对象的指针"><a href="#强三色不变式-不存在黑色对象引用到白色对象的指针" class="headerlink" title="强三色不变式 - 不存在黑色对象引用到白色对象的指针"></a>强三色不变式 - 不存在黑色对象引用到白色对象的指针</h4><p><img src="sw-1.png" alt="sw-1"></p>
<h4 id="弱三色不变式-所有被黑色对象引用的白色对象都处于灰色保护状态"><a href="#弱三色不变式-所有被黑色对象引用的白色对象都处于灰色保护状态" class="headerlink" title="弱三色不变式 - 所有被黑色对象引用的白色对象都处于灰色保护状态"></a>弱三色不变式 - 所有被黑色对象引用的白色对象都处于灰色保护状态</h4><p><img src="sw-2.png" alt="sw-2"></p>
<p>为了遵循上述的两个方式,Golang团队初步得到了两种屏障方式<code>插入屏障</code>和<code>删除屏障</code></p>
<h3 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h3><p><strong>具体操作</strong>: 在<code>A对象</code>引用<code>B对象</code>的时候，<code>B对象</code>被标记为灰色。(将B挂在A下游，B必须被标记为<code>灰色</code>)<br><strong>满足</strong>: <strong>强三色不变式</strong>. (不存在<code>黑色</code>对象引用<code>白色</code>对象的情况了， 因为<code>白色</code>会强制变成<code>灰色</code>)</p>
<p>伪码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;   </span><br><span class="line">  &#x2F;&#x2F;1</span><br><span class="line">  标记灰色(新下游对象ptr)   </span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;2</span><br><span class="line">  当前下游对象slot &#x3D; 新下游对象ptr                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A.添加下游对象(nil, B)   &#x2F;&#x2F;A 之前没有下游， 新添加一个下游对象B， B被标记为灰色</span><br><span class="line">A.添加下游对象(C, B)     &#x2F;&#x2F;A 将下游对象C 更换为B，  B被标记为灰色</span><br></pre></td></tr></table></figure>
<p>这段伪码逻辑就是写屏障.<br>我们知道,<code>黑色</code>对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>.<br><code>栈</code>空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用,所以<code>插入屏障</code>机制,在<code>栈</code>空间的对象操作中不使用.<br>而仅仅使用在<code>堆</code>空间对象的操作中.</p>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。<br><img src="sw-3.png" alt="sw-3"><br><img src="sw-4.png" alt="sw-4"><br><img src="sw-5.png" alt="sw-5"><br><img src="sw-6.png" alt="sw-6"><br><img src="sw-7.png" alt="sw-7"><br><img src="sw-8.png" alt="sw-8"><br>但是如果<code>栈</code>不添加,当全部三色标记扫描之后,<code>栈</code>上有可能依然存在<code>白色</code>对象被引用的情况(如上图的<code>对象9</code>).<br>所以要对<code>栈</code>重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动<code>STW</code>暂停.<br>直到栈空间的三色标记结束.<br><img src="sw-9.png" alt="sw-9"><br><img src="sw-10.png" alt="sw-10"><br><img src="sw-11.png" alt="sw-11"><br>最后将<code>栈</code>和<code>堆</code>空间扫描剩余的全部<code>白色</code>节点清除. 这次<code>STW</code>大约的时间在<code>10~100ms</code>间.<br><img src="sw-12.png" alt="sw-12"></p>
<h3 id="删除屏蔽"><a href="#删除屏蔽" class="headerlink" title="删除屏蔽"></a>删除屏蔽</h3><p><strong>具体操作</strong>: 被删除的对象，如果自身为<code>灰色</code>或者<code>白色</code>，那么被标记为<code>灰色</code>。<br><strong>满足</strong>: <strong>弱三色不变式</strong>. (保护<code>灰色</code>对象到<code>白色</code>对象的路径不会断)</p>
<p>伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot， 新下游对象ptr) &#123;</span><br><span class="line">  &#x2F;&#x2F;1</span><br><span class="line">  if (当前对象是灰色 || 当前对象是白色) &#123;</span><br><span class="line">      标记灰色(当前下游对象slot)     &#x2F;&#x2F;slot为被删除对象， 标记为灰色</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;2</span><br><span class="line">  当前下游对象slot &#x3D; 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A.添加下游对象(B, nil)   &#x2F;&#x2F;A对象，删除B对象的引用  B被A删除，被标记为灰(如果A为灰度或者A为白色)</span><br><span class="line">A.添加下游对象(B, C)     &#x2F;&#x2F;A对象，更换下游B变成C   B被A删除，被标记为灰(如果A为灰度或者A为白色)</span><br></pre></td></tr></table></figure>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。<br><img src="sw-13.png" alt="sw-13"><br><img src="sw-14.png" alt="sw-14"><br><img src="sw-15.png" alt="sw-15"><br><img src="sw-16.png" alt="sw-16"><br><img src="sw-17.png" alt="sw-17"><br><img src="sw-18.png" alt="sw-18"><br><img src="sw-19.png" alt="sw-19"></p>
<p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p>
<h2 id="六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制"><a href="#六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制" class="headerlink" title="六、Go V1.8的混合写屏障(hybrid write barrier)机制"></a>六、Go V1.8的混合写屏障(hybrid write barrier)机制</h2><p>插入写屏障和删除写屏障的短板：</p>
<ul>
<li>插入写屏障：结束时需要<code>STW</code>来重新扫描栈，标记栈上引用的<code>白色</code>对象的存活；</li>
<li>删除写屏障：回收精度低，GC开始时<code>STW</code>扫描<code>堆栈</code>来记录初始快照，这个过程会保护开始时刻的所有存活对象。<br>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了<code>STW</code>的时间。结合了两者的优点。</li>
</ul>
<h3 id="混合写屏障规则"><a href="#混合写屏障规则" class="headerlink" title="混合写屏障规则"></a>混合写屏障规则</h3><p><strong>具体操作</strong>:</p>
<ul>
<li>GC开始将<code>栈</code>上的对象全部扫描并标记为<code>黑色</code>(之后不再进行第二次重复扫描，无需<code>STW</code>)，</li>
<li>GC期间，任何在栈上创建的新对象，均为<code>黑色</code>。</li>
<li>被删除的对象标记为<code>灰色</code>。</li>
<li>被添加的对象标记为<code>灰色</code>。</li>
</ul>
<p><strong>满足</strong>: <strong>变形的弱三色不变式</strong></p>
<p><strong>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率</strong></p>
<p>伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;</span><br><span class="line">    &#x2F;&#x2F;1 </span><br><span class="line">    标记灰色(当前下游对象slot)    &#x2F;&#x2F;只要当前下游对象被移走，就标记灰色</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F;2 </span><br><span class="line">    标记灰色(新下游对象ptr)</span><br><span class="line">          </span><br><span class="line">    &#x2F;&#x2F;3</span><br><span class="line">    当前下游对象slot &#x3D; 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="混合写屏障的具体场景分析"><a href="#混合写屏障的具体场景分析" class="headerlink" title="混合写屏障的具体场景分析"></a>混合写屏障的具体场景分析</h3><p>注意<code>混合写屏障</code>是<code>GC</code>的一种屏障机制，所以只是当程序执行<code>GC</code>的时候，才会触发这种机制。<br>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<p><strong>GC开始：扫描栈区，将可达对象全部标记为黑</strong><br><img src="hwb-1.png" alt="hwb-1"><br><img src="hwb-2.png" alt="hwb-2"></p>
<p><strong>场景一</strong><br>对象被一个<code>堆</code>对象删除引用，成为<code>栈</code>对象的下游<br>伪代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;前提：堆对象4-&gt;对象7 &#x3D; 对象7；  &#x2F;&#x2F;对象7 被 对象4引用</span><br><span class="line">栈对象1-&gt;对象7 &#x3D; 堆对象7；  &#x2F;&#x2F;将堆对象7 挂在 栈对象1 下游</span><br><span class="line">堆对象4-&gt;对象7 &#x3D; null；    &#x2F;&#x2F;对象4 删除引用 对象7</span><br></pre></td></tr></table></figure>
<p><img src="hwb-3.png" alt="hwb-3"><br><img src="hwb-4.png" alt="hwb-4"></p>
<p><strong>场景二</strong><br>对象被一个<code>栈</code>对象删除引用，成为另一个<code>栈</code>对象的下游<br>伪代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new 栈对象9；</span><br><span class="line">对象8-&gt;对象3 &#x3D; 对象3；      &#x2F;&#x2F;将栈对象3 挂在 栈对象9 下游</span><br><span class="line">对象2-&gt;对象3 &#x3D; null；      &#x2F;&#x2F;对象2 删除引用 对象3</span><br></pre></td></tr></table></figure>
<p><img src="hwb-5.png" alt="hwb-5"><br><img src="hwb-6.png" alt="hwb-6"><br><img src="hwb-7.png" alt="hwb-7"></p>
<p><strong>场景三</strong><br>对象被一个<code>堆</code>对象删除引用，成为另一个<code>堆</code>对象的下游<br>伪代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆对象10-&gt;对象7 &#x3D; 堆对象7；       &#x2F;&#x2F;将堆对象7 挂在 堆对象10 下游</span><br><span class="line">堆对象4-&gt;对象7 &#x3D; null；         &#x2F;&#x2F;对象4 删除引用 对象7</span><br></pre></td></tr></table></figure>
<p><img src="hwb-8.png" alt="hwb-8"><br><img src="hwb-9.png" alt="hwb-9"><br><img src="hwb-10.png" alt="hwb-10"></p>
<p><strong>场景四</strong><br>对象从一个<code>栈</code>对象删除引用，成为另一个<code>堆</code>对象的下游<br>伪代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆对象10-&gt;对象7 &#x3D; 堆对象7；       &#x2F;&#x2F;将堆对象7 挂在 堆对象10 下游</span><br><span class="line">堆对象4-&gt;对象7 &#x3D; null；         &#x2F;&#x2F;对象4 删除引用 对象7</span><br></pre></td></tr></table></figure>
<p><img src="hwb-11.png" alt="hwb-11"><br><img src="hwb-12.png" alt="hwb-12"><br><img src="hwb-13.png" alt="hwb-13"></p>
<p>Golang中的<code>混合写屏障</code>满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的<code>栈</code>，使其变<code>黑</code>并一直保持，这个过程不需要<code>STW</code>，而标记结束后，因为<code>栈</code>在扫描后始终是<code>黑色</code>的，也无需再进行re-scan操作了，减少了<code>STW</code>的时间。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。</p>
<p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。<br>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通<br>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>
<p>参考文献:</p>
<ul>
<li><a href="https://www.cnblogs.com/wangyiyang/p/12191591.html">https://www.cnblogs.com/wangyiyang/p/12191591.html</a></li>
<li><a href="https://www.jianshu.com/p/eb6b3aff9ca5">https://www.jianshu.com/p/eb6b3aff9ca5</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/74853110">https://zhuanlan.zhihu.com/p/74853110</a></li>
</ul>
<h2 id="相关好博客推荐"><a href="#相关好博客推荐" class="headerlink" title="相关好博客推荐"></a>相关好博客推荐</h2><ul>
<li><a href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html">Garbage Collection In Go : Part I - Semantics</a></li>
<li><a href="https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html">Garbage Collection In Go : Part II - GC Traces</a></li>
<li><a href="https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html">Garbage Collection In Go : Part III - GC Pacing</a></li>
</ul>
<p><strong>原文作者:</strong> <a href="https://segmentfault.com/u/aceld">刘丹冰 Aceld</a><br><strong>原文地址:</strong> <a href="https://segmentfault.com/a/1190000022030353">Golang三色标记、混合写屏障GC模式图文全分析</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>gc</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>gin vs net/http</title>
    <url>/2021/02/23/golang-gin-vs-http/</url>
    <content><![CDATA[<h2 id="gin-优点"><a href="#gin-优点" class="headerlink" title="gin 优点"></a>gin 优点</h2><ul>
<li>轻量框架，提供web服务的常用工具函数(如panic捕获，json格式校验等等)。开发者可以以少量代码，轻松构建web服务。</li>
<li>以中间件抽象通用逻辑（如鉴权，检验入参，日志审计等逻辑），供一个或一组URL使用，提高代码复用率。</li>
<li>基于上述的中间件特性，代码具有很强的可扩展性。</li>
<li>支持常见的render模板(json, xml, html, yaml, string), 满足轻松动态资源，后端api服务等多种业务场景。</li>
<li>更高的路由匹配效率。 </li>
<li>使用context池，减少runtime的GC工作量。</li>
</ul>
<h2 id="net-http-和-gin-的关系"><a href="#net-http-和-gin-的关系" class="headerlink" title="net/http 和 gin 的关系"></a>net/http 和 gin 的关系</h2><ul>
<li><p>gin更像是一个功能强大的路由器，提供更便捷的web服务解决方案，而其余功能则复用net/http。</p>
</li>
<li><p>网络层实现，http parser 都是由 net/http 实现的。<br><img src="gin-1.png" alt="gin-1"></p>
<h2 id="强大的工具包-gin-Context"><a href="#强大的工具包-gin-Context" class="headerlink" title="强大的工具包: gin.Context"></a>强大的工具包: gin.Context</h2><h3 id="gin-Context-的功能"><a href="#gin-Context-的功能" class="headerlink" title="gin.Context 的功能"></a>gin.Context 的功能</h3><p>在日常的web服务开发中，我们总会频繁地使用以下功能：</p>
</li>
<li><p>获取query参数</p>
</li>
<li><p>读取POST或PUT的请求体</p>
</li>
<li><p>请求体的反序列化以及响应体的序列化</p>
</li>
<li><p>读写 HTTP Header</p>
</li>
<li><p>读写 cookie<br>而gin.Context, 作为一个web框架通用函数工具包，涵盖了上述的功能。<br>此前，笔者没有阅读源码之前，一直以为gin.Context实现了context.Context的Deadline函数，可以用来做一些熔断相关的功能，<br>但其实并没有，类似的功能还是要依赖 net/http 的 Request.Context()来实现。</p>
</li>
</ul>
<h3 id="gin-Context-的优势"><a href="#gin-Context-的优势" class="headerlink" title="gin.Context 的优势"></a>gin.Context 的优势</h3><h2 id="效率更高的路由器：Radix-Tree"><a href="#效率更高的路由器：Radix-Tree" class="headerlink" title="效率更高的路由器：Radix Tree"></a>效率更高的路由器：Radix Tree</h2><h3 id="net-http-路由器的实现"><a href="#net-http-路由器的实现" class="headerlink" title="net/http 路由器的实现"></a>net/http 路由器的实现</h3><h3 id="gin-路由器的实现-radix-tree"><a href="#gin-路由器的实现-radix-tree" class="headerlink" title="gin 路由器的实现: radix tree"></a>gin 路由器的实现: radix tree</h3><h3 id="两种路由器实现的效率差异"><a href="#两种路由器实现的效率差异" class="headerlink" title="两种路由器实现的效率差异"></a>两种路由器实现的效率差异</h3><h2 id="更优雅的抽象：中间件"><a href="#更优雅的抽象：中间件" class="headerlink" title="更优雅的抽象：中间件"></a>更优雅的抽象：中间件</h2>]]></content>
      <tags>
        <tag>golang</tag>
        <tag>面试题</tag>
        <tag>gin</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解析 Go 中 Slice 底层实现</title>
    <url>/2021/02/03/golang-slice/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>切片本身并不是动态数组或者数组指针。<br>它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。<br><strong>切片本身是一个只读对象，其工作机制类似数组指针的一种封装</strong>。</p>
<p>切片是对数组一个连续片段的引用，所以切片是一个引用类型。<br>这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。<br>需要注意的是，终止索引标识的项不包括在切片内。<br>切片提供了一个与指向数组的动态窗口。</p>
<p>给定项的切片索引可能比相关数组的相同元素的索引小。<br>切片的长度可以在运行时修改。</p>
<p>Slice 的数据结构定义如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="slice-1.png" alt="slice-1"><br><img src="slice-2.png" alt="slice-2"></p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="空切片和nil切片"><a href="#空切片和nil切片" class="headerlink" title="空切片和nil切片"></a>空切片和nil切片</h3><p><img src="slice-3.png" alt="slice-3"><br><img src="slice-4.png" alt="slice-4"><br>空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。<br>最后需要说明的一点是。不管是使用 nil 切片还是空切片，对其调用内置函数 append，len 和 cap 的效果都是一样的。</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>当一个切片的容量满了，就需要扩容了。怎么扩，策略是什么？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc(unsafe.Pointer(&amp;et))</span><br><span class="line">		racereadrangepc(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)), callerpc, funcPC(growslice))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果新要扩容的容量比原来的容量还要小，这代表要缩容了，那么可以直接报panic了。</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果当前切片的大小为0，还调用了扩容方法，那么就新生成一个新的容量的切片返回。</span></span><br><span class="line">		<span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), old.<span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是扩容的策略</span></span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">			<span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">			<span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算新的切片的容量，长度。</span></span><br><span class="line">	<span class="keyword">var</span> lenmem, newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line">	<span class="keyword">const</span> ptrSize = unsafe.Sizeof((*<span class="keyword">byte</span>)(<span class="literal">nil</span>))</span><br><span class="line">	<span class="keyword">switch</span> et.size &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line">	<span class="keyword">case</span> ptrSize:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * ptrSize</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * ptrSize</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / ptrSize)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * et.size)</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断非法的值，保证容量是在增加，并且容量不超过最大容量</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> || <span class="keyword">uintptr</span>(newcap) &gt; maxSliceCap(et.size) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> et.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 在老的切片后面继续扩充容量</span></span><br><span class="line">		p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		<span class="comment">// 将 lenmem 这个多个 bytes 从 old.array地址 拷贝到 p 的地址处</span></span><br><span class="line">		memmove(p, old.array, lenmem)</span><br><span class="line">		<span class="comment">// 先将 P 地址加上新的容量得到新切片容量的地址，然后将新切片容量地址后面的 capmem-newlenmem 个 bytes 这块内存初始化。为之后继续 append() 操作腾出空间。</span></span><br><span class="line">		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 重新申请新的数组给新切片</span></span><br><span class="line">		<span class="comment">// 重新申请 capmen 这个大的内存地址，并且初始化为0值</span></span><br><span class="line">		p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> !writeBarrier.enabled &#123;</span><br><span class="line">			<span class="comment">// 如果还不能打开写锁，那么只能把 lenmem 大小的 bytes 字节从 old.array 拷贝到 p 的地址处</span></span><br><span class="line">			memmove(p, old.array, lenmem)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 循环拷贝老的切片的值</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; lenmem; i += et.size &#123;</span><br><span class="line">				typedmemmove(et, add(p, i), add(old.array, i))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回最终新切片，容量更新为最新扩容之后的容量</span></span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述就是扩容的实现。主要需要关注的有两点，一个是扩容时候的策略，还有一个就是扩容是生成全新的内存地址还是在原来的地址后追加。</p>
<h3 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h3><p>Go 中切片扩容的策略是这样的：</p>
<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap） </li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li>
</ul>
<h3 id="扩容之后的数组是新数组还是老数组"><a href="#扩容之后的数组是新数组还是老数组" class="headerlink" title="扩容之后的数组是新数组还是老数组"></a>扩容之后的数组是新数组还是老数组</h3><p><strong>情况一</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	array := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">	slice := array[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">	newSlice := <span class="built_in">append</span>(slice, <span class="number">50</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Before slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, slice, &amp;slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Before newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, newSlice, &amp;newSlice, <span class="built_in">len</span>(newSlice), <span class="built_in">cap</span>(newSlice))</span><br><span class="line">	newSlice[<span class="number">1</span>] += <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;After slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, slice, &amp;slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;After newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, newSlice, &amp;newSlice, <span class="built_in">len</span>(newSlice), <span class="built_in">cap</span>(newSlice))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;After array = %v\n&quot;</span>, array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Before slice = [10 20], Pointer = 0xc4200c0040, len = 2, cap = 4</span><br><span class="line">Before newSlice = [10 20 50], Pointer = 0xc4200c0060, len = 3, cap = 4</span><br><span class="line">After slice = [10 30], Pointer = 0xc4200c0040, len = 2, cap = 4</span><br><span class="line">After newSlice = [10 30 50], Pointer = 0xc4200c0060, len = 3, cap = 4</span><br><span class="line">After array = [10 30 50 40]</span><br></pre></td></tr></table></figure>
<p>把上述过程用图表示出来，如下图。<br><img src="slice-5.png" alt="slice-5"><br>通过打印的结果，我们可以看到，在这种情况下，扩容以后并没有新建一个新的数组，扩容前后的数组都是同一个，这也就导致了新的切片修改了一个值，也影响到了老的切片了。<br>并且 append() 操作也改变了原来数组里面的值。<br>一个 append() 操作影响了这么多地方，如果原数组上有多个切片，那么这些切片都会被影响！无意间就产生了莫名的 bug！<br>这种情况，由于原数组还有容量可以扩容，所以执行 append() 操作以后，会在原数组上直接操作，所以这种情况下，扩容以后的数组还是指向原来的数组。<br>这种情况也极容易出现在字面量创建切片时候，第三个参数 cap 传值的时候，如果用字面量创建切片，cap 并不等于指向数组的总容量，那么这种情况就会发生。<br>上面这种情况非常危险，极度容易产生 bug 。<br>建议用字面量创建切片的时候，cap 的值一定要保持清醒，避免共享原数组导致的 bug。</p>
<p><strong>情况二</strong><br>情况二其实就是在扩容策略里面举的例子，在那个例子中之所以生成了新的切片，是因为原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。<br>所以建议尽量避免情况一，尽量使用情况二，避免 bug 产生。</p>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>Slice 中拷贝方法有2个</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(to, fm slice, width <span class="keyword">uintptr</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return </span></span><br><span class="line">	<span class="keyword">if</span> fm.<span class="built_in">len</span> == <span class="number">0</span> || to.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// n 记录下源切片或者目标切片较短的那一个的长度</span></span><br><span class="line">	n := fm.<span class="built_in">len</span></span><br><span class="line">	<span class="keyword">if</span> to.<span class="built_in">len</span> &lt; n &#123;</span><br><span class="line">		n = to.<span class="built_in">len</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果入参 width = 0，也不需要拷贝了，返回较短的切片的长度</span></span><br><span class="line">	<span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果开启了竞争检测</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc(unsafe.Pointer(&amp;to))</span><br><span class="line">		pc := funcPC(slicecopy)</span><br><span class="line">		racewriterangepc(to.array, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)), callerpc, pc)</span><br><span class="line">		racereadrangepc(fm.array, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)), callerpc, pc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果开启了 The memory sanitizer (msan)</span></span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanwrite(to.array, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)))</span><br><span class="line">		msanread(fm.array, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	size := <span class="keyword">uintptr</span>(n) * width</span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">1</span> &#123; </span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> is this still worth it with new memmove impl?</span></span><br><span class="line">		<span class="comment">// 如果只有一个元素，那么指针直接转换即可</span></span><br><span class="line">		*(*<span class="keyword">byte</span>)(to.array) = *(*<span class="keyword">byte</span>)(fm.array) <span class="comment">// known to be a byte pointer</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果不止一个元素，那么就把 size 个 bytes 从 fm.array 地址开始，拷贝到 to.array 地址之后</span></span><br><span class="line">		memmove(to.array, fm.array, size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，slicecopy 方法会把源切片值(即 fm Slice )中的元素复制到目标切片(即 to Slice )中，并返回被复制的元素个数，copy 的两个类型必须一致。slicecopy 方法最终的复制结果取决于较短的那个切片，当较短的切片复制完成，整个复制过程就全部完成了。<br><img src="slice-6.png" alt="slice-6"></p>
<p>举个例子，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	array := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">6</span>)</span><br><span class="line">	n := <span class="built_in">copy</span>(slice, array)</span><br><span class="line">	fmt.Println(n,slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个拷贝的方法，这个方法原理和 slicecopy 方法类似，不在赘述了，注释写在代码里面了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicestringcopy</span><span class="params">(to []<span class="keyword">byte</span>, fm <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return </span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(fm) == <span class="number">0</span> || <span class="built_in">len</span>(to) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// n 记录下源切片或者目标切片较短的那一个的长度</span></span><br><span class="line">	n := <span class="built_in">len</span>(fm)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(to) &lt; n &#123;</span><br><span class="line">		n = <span class="built_in">len</span>(to)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果开启了竞争检测</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc(unsafe.Pointer(&amp;to))</span><br><span class="line">		pc := funcPC(slicestringcopy)</span><br><span class="line">		racewriterangepc(unsafe.Pointer(&amp;to[<span class="number">0</span>]), <span class="keyword">uintptr</span>(n), callerpc, pc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果开启了 The memory sanitizer (msan)</span></span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanwrite(unsafe.Pointer(&amp;to[<span class="number">0</span>]), <span class="keyword">uintptr</span>(n))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 拷贝字符串至字节数组</span></span><br><span class="line">	memmove(unsafe.Pointer(&amp;to[<span class="number">0</span>]), stringStructOf(&amp;fm).str, <span class="keyword">uintptr</span>(n))</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再举个例子，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">3</span>)</span><br><span class="line">	n := <span class="built_in">copy</span>(slice, <span class="string">&quot;abcdef&quot;</span>)</span><br><span class="line">	fmt.Println(n,slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说到拷贝，切片中有一个需要注意的问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;value = %d , value-addr = %x , slice-addr = %x\n&quot;</span>, value, &amp;value, &amp;slice[index])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">value = 10 , value-addr = c4200aedf8 , slice-addr = c4200b0320</span><br><span class="line">value = 20 , value-addr = c4200aedf8 , slice-addr = c4200b0328</span><br><span class="line">value = 30 , value-addr = c4200aedf8 , slice-addr = c4200b0330</span><br><span class="line">value = 40 , value-addr = c4200aedf8 , slice-addr = c4200b0338</span><br></pre></td></tr></table></figure>
<p>从上面结果我们可以看到，如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。<br>所以每次打印 Value 的地址都不变。</p>
<p><img src="slice-7.png" alt="slice-7"><br>由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &amp;slice[index] 获取真实的地址。</p>
<p><strong>原文地址:</strong> <a href="https://halfrost.com/go_slice/">深入解析 Go 中 Slice 底层实现</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>slice</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程的虚拟内存</title>
    <url>/2021/01/31/linux-process-vm/</url>
    <content><![CDATA[<p><strong>当我们创建一个进程时，我们知道进程有以下特点</strong>：</p>
<ul>
<li>每个进程都有自己独立的4G虚拟内存空间，各个进程的内存空间具有类似的结构</li>
<li>一个新进程建立的时候，将会建立起自己的内存空间，此进程的数据，代码等从磁盘拷贝到自己的进程空间，哪些数据在哪里，都由进程控制表中的task_struct记录，task_struct中记录中一条链表，记录中内存空间的分配情况，哪些地址有数据，哪些地址无数据，哪些可读，哪些可写，都可以通过这个链表记录 </li>
<li>每个进程已经分配的内存空间，都与对应的磁盘空间映射</li>
</ul>
<p><strong>那么问题来了</strong>：</p>
<ul>
<li>计算机明明没有那么多内存（n个进程的话就需要n*4G）内存</li>
<li>建立一个进程，就要把磁盘上的程序文件拷贝到进程对应的内存中去，对于一个程序对应的多个进程这种情况，浪费内存！</li>
</ul>
<p><strong>所以，实际上</strong>：</p>
<ul>
<li>每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址 </li>
<li>所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。</li>
<li>进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录</li>
<li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）</li>
<li>当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常</li>
<li>缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘<br>进程的虚拟内存地址与实际物理内存映射理解图如下：<br><img src="1.png" alt="1.png"></li>
</ul>
<p>页表工作原理及映射关系理解图如下：<br><img src="2.png" alt="2.png"></p>
<p>可以认为虚拟空间都被映射到了磁盘空间中，并且由页表记录映射位置，当访问到某个地址的时候，通过页表中的有效位，可以得知此数据是否在内存中，如果不是，则通过缺页异常，将磁盘对应的数据拷贝到内存中，如果没有空闲内存，则选择牺牲页面，替换其他页面。</p>
<p>事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p>
<p><strong>应用虚拟内存机制有很多优点</strong>：</p>
<ul>
<li>既然每个进程的内存空间都是一致而且固定的，所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际的内存地址，这是有独立内存空间的好处</li>
<li>当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</li>
<li>在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</li>
</ul>
]]></content>
      <tags>
        <tag>虚拟内存</tag>
        <tag>linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown Emoji</title>
    <url>/2021/01/31/markdown-emoji/</url>
    <content><![CDATA[<div class="row">
<div class="col col-sm-3">
<p><span class="github-emoji" alias="smile" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">&#x1f604;</span> <code>:smile:</code> </p>

</div> 
<div class="col col-sm-3">
<p><span class="github-emoji" alias="rage" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f621.png?v8">&#x1f621;</span> <code>:rage:</code> </p>

</div> 
<div class="col col-sm-3">
<p><span class="github-emoji" alias="x" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">&#x274c;</span> <code>:x:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="clock1130" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f566.png?v8">&#x1f566;</span> <code>:clock1130:</code> </p>

</div>
</div>
<div class="row">
<div class="col col-sm-3">
<p><span class="github-emoji" alias="house" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3e0.png?v8">&#x1f3e0;</span> <code>:house:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="fire" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8">&#x1f525;</span> <code>:fire:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="sun_with_face" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">&#x1f31e;</span> <code>:sun_with_face:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="one" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8">&#x0031;&#xfe0f;&#x20e3;</span> <code>:one:</code> </p>

</div>
</div>
<div class="row">
<div class="col col-sm-3">
<p><span class="github-emoji" alias="recycle" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/267b.png?v8">&#x267b;</span> <code>:recycle:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="dart" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3af.png?v8">&#x1f3af;</span> <code>:dart:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="libra" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/264e.png?v8">&#x264e;</span> <code>:libra:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="underage" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f51e.png?v8">&#x1f51e;</span> <code>:underage:</code> </p>

</div>
</div>

<blockquote>
<p>Check out the <a href="https://www.webfx.com/tools/emoji-cheat-sheet/">Emoji Cheat Sheet</a> for all the emojis it supports</p>
</blockquote>
]]></content>
      <tags>
        <tag>emoji</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql常见面试题</title>
    <url>/2021/02/05/mysql-interview/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>面试题</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>【项目介绍】发布平台</title>
    <url>/2021/03/01/project-mb-phantom/</url>
    <content><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>公司现有的发布平台（简称老平台）使用Python的Django框架开发，随着业务量的提升，逐渐的出现的性能问题（发布高峰期接口返回明显时间大大的增加）<br>而老平台由于初期的架构设计已经日积月累的代码补丁，修复老平台代码变得异常困难。</p>
<h2 id="我们先看看老平台有哪些问题"><a href="#我们先看看老平台有哪些问题" class="headerlink" title="我们先看看老平台有哪些问题"></a>我们先看看老平台有哪些问题</h2><h3 id="老平台架构"><a href="#老平台架构" class="headerlink" title="老平台架构"></a>老平台架构</h3><p><img src="phantom-1.png" alt="phantom-1"></p>
<h4 id="服务信息管理模块"><a href="#服务信息管理模块" class="headerlink" title="服务信息管理模块"></a>服务信息管理模块</h4><p>管理服务的相关信息（名称，应用类型，打包命令，启动命令，停止命令，容器配置，人员配置，发布配置）</p>
<h4 id="发布流程控制模块"><a href="#发布流程控制模块" class="headerlink" title="发布流程控制模块"></a>发布流程控制模块</h4><p>管理发布任务的流程：<br>创建任务 -&gt; 前置检查 -&gt; 打包 -&gt; 创建或者更新容器 -&gt; 服务启动检查 -&gt; 完成任务（回滚）</p>
<h4 id="权限模块"><a href="#权限模块" class="headerlink" title="权限模块"></a>权限模块</h4><p>管理人员信息，以及人员和项目的愿权限关系</p>
<h3 id="问题一：所有服务直接访问mysql"><a href="#问题一：所有服务直接访问mysql" class="headerlink" title="问题一：所有服务直接访问mysql"></a>问题一：所有服务直接访问mysql</h3><p>一开始这样其实也没什么大问题，毕竟系统都是一步一步做的，最初业务量不大的情况下，直接访问mysql，开发效率要高一些。<br>但是业务量的逐渐增加问题就来了，表越来越大，sql查询越来越慢，系统也越来越慢。</p>
<h3 id="问题二：三个服务职能没有分的很开"><a href="#问题二：三个服务职能没有分的很开" class="headerlink" title="问题二：三个服务职能没有分的很开"></a>问题二：三个服务职能没有分的很开</h3><p>服务信息管理存了服务的人员信息，权限模块也存储了人员信息，两者通过同步的方式来保证一致性。<br>服务的容器配置（容器数量，cpu，memory，hpa等），在发布流程控制和服务准入里面都有，也是通过同步的方式来保证一致性。</p>
<p>愿景都是美好的，我们通过同步的方式来相互同步信息，但是随着时间的推移，出现了大量的脏数据，清理花了我们很长时间，找问题也花了很长时间，反反复复的修改了好次。<br>最终起了一些定时任务，每天夜里定时全量同步。但是并没有解决问题，因为白天产生的不同步的问题，依然会给服务方带来不便。</p>
<h3 id="问题三：各个模块之间直接通过http接口相互调用"><a href="#问题三：各个模块之间直接通过http接口相互调用" class="headerlink" title="问题三：各个模块之间直接通过http接口相互调用"></a>问题三：各个模块之间直接通过http接口相互调用</h3><p>一个接口有问题，整个平台GG。<br>直接使用ip端口调用，服务水平扩展成了幻想。<br>服务器故障，迁移如登天。</p>
<p>做过一些优化：</p>
<ul>
<li>服务内部同步域名访问</li>
<li>服务上面加一层 nginx模块作为代理，实现的服务能够水平扩展</li>
</ul>
<h3 id="问题四：前后虽然分离了，但是很多业务逻辑出现在了前端"><a href="#问题四：前后虽然分离了，但是很多业务逻辑出现在了前端" class="headerlink" title="问题四：前后虽然分离了，但是很多业务逻辑出现在了前端"></a>问题四：前后虽然分离了，但是很多业务逻辑出现在了前端</h3><p>比如， dev环境自动发布是由前端触发的；应用的容器列表，通过前端刷新了之后更新到后端<br>说的好听些是前后端分离的架构，其实还不如不分离，维护成本大大的提升，还有没有带来收益。</p>
<h3 id="问题五：多个k8s集群直接调用"><a href="#问题五：多个k8s集群直接调用" class="headerlink" title="问题五：多个k8s集群直接调用"></a>问题五：多个k8s集群直接调用</h3><ul>
<li>每次都要根据不同的机房加载k8s config</li>
<li>k8s接口接口复杂，对于开发有学习成本</li>
</ul>
<h2 id="新平台优化"><a href="#新平台优化" class="headerlink" title="新平台优化"></a>新平台优化</h2><h3 id="新平台架构"><a href="#新平台架构" class="headerlink" title="新平台架构"></a>新平台架构</h3><p><img src="phantom-2.png" alt="phantom-2"></p>
<h3 id="优化一：将原来的3个服务拆分成了13个微服务，同时添加服务注册中心"><a href="#优化一：将原来的3个服务拆分成了13个微服务，同时添加服务注册中心" class="headerlink" title="优化一：将原来的3个服务拆分成了13个微服务，同时添加服务注册中心"></a>优化一：将原来的3个服务拆分成了13个微服务，同时添加服务注册中心</h3><ul>
<li><strong>发布系统</strong>：发布流程管理，容器配置管理</li>
<li><strong>打包系统</strong>：打包配置管理，完成发布的打包任务</li>
<li><strong>服务准入</strong>：服务的基本信息</li>
<li><strong>权限系统</strong>：管理用户的权限</li>
<li><strong>管理系统</strong>：管理员后台系统，用于一些系统配置，比如添加jar版本检查，添加维护规则，添加白名单等</li>
<li><strong>平台事件</strong>：搜集平台的事件写入MQ，比如应用开始发布，应用权限修改，应用信息修改，重启容器，销毁容器等等</li>
<li><strong>工单系统</strong>：管理流程审批</li>
<li><strong>前置检查</strong>：发布前检查当前发布是否可以进行</li>
<li><strong>平台事件发送系统</strong>：从MQ读取事件，更具配置发送到指定的钉钉群</li>
<li><strong>事件消费</strong>：这里的事件是K8S的事件和上面的平台事件是不一样的，改逐渐主要消费K8S产生的Pod， Deployment，HPA的事件</li>
<li><strong>事件系统</strong>：生产K8S的变更事件</li>
<li><strong>Runtime</strong>：K8S controller复杂封装K8S接口</li>
</ul>
<p>架构支持服务自动水平扩容；<br>注册中心有失败重试的机制，一个服务有问题，会尝试调用其他节点；</p>
<h3 id="优化二：在K8S上加了一层"><a href="#优化二：在K8S上加了一层" class="headerlink" title="优化二：在K8S上加了一层"></a>优化二：在K8S上加了一层</h3><blockquote>
<p>没有什么问题是加一层解决不了的，如果有，就加两层</p>
</blockquote>
<p>我们有多套K8S集群，之前是直接调用K8S的接口的，每个集群都是单独一个client。<br>加了runtime之后，runtime对K8S的接口进行了二次封装，平台内部不需要在管理各个K8S集群的client，直接调用RunTime服务就好。<br>优化入参和返回值，符合系统整体的标准。<br>整合一个底层接口，一个接口完成一套业务。</p>
<h3 id="优化三：K8S事件和平台事件接入MQ"><a href="#优化三：K8S事件和平台事件接入MQ" class="headerlink" title="优化三：K8S事件和平台事件接入MQ"></a>优化三：K8S事件和平台事件接入MQ</h3><p>防治了因为接口调用失败，导致的事件丢失<br>平台事件可以提供给他部门使用<br>当K8S产生大量事件的时候，MQ启动很好的消峰作用</p>
<h3 id="优化四：添加redis缓存"><a href="#优化四：添加redis缓存" class="headerlink" title="优化四：添加redis缓存"></a>优化四：添加redis缓存</h3><p>所有服务添加缓存机制，大大的加快的查询的速度，同时也大大的减小的mysql的压力</p>
<h3 id="优化五：mysql各个系统独立的database，读写分离。"><a href="#优化五：mysql各个系统独立的database，读写分离。" class="headerlink" title="优化五：mysql各个系统独立的database，读写分离。"></a>优化五：mysql各个系统独立的database，读写分离。</h3><p>各个系统独立database互不影响<br>读写分离，同时提升了读和写的效率</p>
<h3 id="优化六：-统一的网关服务暴露restful接口"><a href="#优化六：-统一的网关服务暴露restful接口" class="headerlink" title="优化六： 统一的网关服务暴露restful接口"></a>优化六： 统一的网关服务暴露restful接口</h3><p>各个服务只需要编写RPC方法就好，由网关服务统一进行restful和RPC的转化。</p>
<h2 id="有待继续优化"><a href="#有待继续优化" class="headerlink" title="有待继续优化"></a>有待继续优化</h2><ul>
<li>DB上层应该要再加一层DB连接控制层</li>
<li>session虽然做了redis缓存，但是不应该用mysql存储，直接放在redis里面就好了</li>
<li>redis只要string的数据类型，其他同的信息可以用不用的类型存储</li>
<li>k8s事件只写到了一个分片里面，因为消费事件需要是有续的，所有分片，多个消费者的情况下就变得无序了</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实新平台的架构并不是很先进，也就是常规的微服务的架构。<br>在cache，DB，MQ的选型上并没有花太多功夫，主要考虑了自己熟悉的服务。<br>系统是一步一步迭代的，老平台 -&gt; 新平台 的优化，主要是针对老平台的缺点来的，新平台应该也会有一些问题。<br>我只一步一步的走，但当前平台又不能处理现有的业务场景的时候，就是考虑下一代架构的时候了。</p>
<h2 id="附上一些系统图片"><a href="#附上一些系统图片" class="headerlink" title="附上一些系统图片"></a>附上一些系统图片</h2><p><img src="phantom-3.png" alt="phantom-3"><br><img src="phantom-4.png" alt="phantom-4"><br><img src="phantom-5.png" alt="phantom-5"><br><img src="phantom-6.png" alt="phantom-6"><br><img src="phantom-7.png" alt="phantom-7"><br><img src="phantom-8.png" alt="phantom-8"><br><img src="phantom-9.png" alt="phantom-9"><br><img src="phantom-10.png" alt="phantom-10"><br><img src="phantom-11.png" alt="phantom-11"></p>
]]></content>
      <tags>
        <tag>项目</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang调度器GMP原理与调度全分析</title>
    <url>/2021/01/29/golang-gmp/</url>
    <content><![CDATA[<blockquote>
<p>该文章主要详细具体的介绍Goroutine调度器过程及原理，可以对Go调度器的详细调度过程有一个清晰的理解。</p>
</blockquote>
<h2 id="内容提纲"><a href="#内容提纲" class="headerlink" title="内容提纲"></a>内容提纲</h2><ul>
<li>Golang调度器的由来</li>
<li>Goroutine调度器的GMP模型及设计思想</li>
<li>Goroutine调度场景过程全图文解析</li>
</ul>
<h2 id="一、Golang调度器的由来？"><a href="#一、Golang调度器的由来？" class="headerlink" title="一、Golang调度器的由来？"></a>一、Golang调度器的由来？</h2><h3 id="单进程时代不需要调度器"><a href="#单进程时代不需要调度器" class="headerlink" title="单进程时代不需要调度器"></a>单进程时代不需要调度器</h3><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。<br>早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是<code>单进程时代</code>, 一切的程序只能串行发生。<br><img src="sproc-1.png" alt="sproc-1"></p>
<p>早期的单进程操作系统，面临2个问题：</p>
<ul>
<li>单一的执行流程，计算机只能一个任务一个任务的处理</li>
<li>进程阻塞所带来的CPU时间浪费<br>那么能不能有多个进程来宏观一起来执行多个任务呢？<br>后来操作系统就具有了最早的并发能力： <strong>多进程并发</strong><br>当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</li>
</ul>
<h3 id="多进程-线程时代有了调度器需求"><a href="#多进程-线程时代有了调度器需求" class="headerlink" title="多进程/线程时代有了调度器需求"></a>多进程/线程时代有了调度器需求</h3><p><img src="mproc-1.png" alt="mproc-1"><br>在多进程/多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞CPU可以立刻切换到其他进程中去执行，而且调度CPU的算法可以保证在运行的进程都可以被分配到CPU的运行时间片。<br>这样从宏观来看，似乎多个进程是在同时被运行。<br>但新的问题就又出现了，进程拥有太多的资源，进程的<strong>创建</strong>、<strong>切换</strong>、<strong>销毁</strong>，都会占用很长的时间。<br>CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。</p>
<p><strong>怎么才能提高CPU的利用率呢？</strong><br><img src="mproc-2.png" alt="mproc-2"><br>很明显，CPU调度切换的是进程和线程。<br>尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p>
<h3 id="协程来提高CPU利用率"><a href="#协程来提高CPU利用率" class="headerlink" title="协程来提高CPU利用率"></a>协程来提高CPU利用率</h3><p>多进程、多线程已经提高了系统的并发能力。<br>但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(<a href="https://blog.zouyapeng.com/2021/01/31/linux-process-vm/">进程虚拟内存</a> 会占用<strong>4GB</strong>[32位操作系统], 而线程也要大约<strong>4MB</strong>)。<br>大量的进程/线程出现了新的问题：</p>
<ul>
<li>高内存占用</li>
<li>调度的高消耗CPU<br>之后，攻城狮们就发现，其实一个线程分为<code>内核态线程</code>和<code>用户态线程</code>。<br>一个<code>用户态线程</code>必须要绑定一个<code>内核态线程</code></li>
</ul>
<p>但是CPU并不知道有<code>用户态线程</code>的存在，它只知道它运行的是一个<code>内核态线程</code>(Linux的PCB进程控制块)。<br><img src="co-routine-1.png" alt="co-routine-1"><br>这样，我们再去细化去分类一下，内核线程依然叫<code>线程(thread)</code>，用户线程叫<code>协程(co-routine)</code>.<br><img src="co-routine-2.png" alt="co-routine-2"><br>看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。<br>之后，我们就看到了有3种协程和线程的映射关系</p>
<h4 id="N-1-关系-N个协程绑定1个线程"><a href="#N-1-关系-N个协程绑定1个线程" class="headerlink" title="N:1 关系(N个协程绑定1个线程)"></a>N:1 关系(N个协程绑定1个线程)</h4><p>优点:</p>
<ul>
<li>协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。<br>缺点：</li>
<li>一个进程的所有协程都绑定在一个线程上。</li>
<li>某个程序用不了硬件的多核加速能力。</li>
<li>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。<br><img src="co-routine-3.png" alt="co-routine-3"></li>
</ul>
<h4 id="1-1-关系-1个协程绑定1个线程"><a href="#1-1-关系-1个协程绑定1个线程" class="headerlink" title="1:1 关系(1个协程绑定1个线程)"></a>1:1 关系(1个协程绑定1个线程)</h4><p>优点: 简单易于实现<br>缺点: </p>
<ul>
<li>协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。<br><img src="co-routine-4.png" alt="co-routine-4"></li>
</ul>
<h4 id="M-N关系-M个协程绑定1个线程-是N-1和1-1类型的结合-但是难以实现"><a href="#M-N关系-M个协程绑定1个线程-是N-1和1-1类型的结合-但是难以实现" class="headerlink" title="M:N关系(M个协程绑定1个线程, 是N:1和1:1类型的结合, 但是难以实现)"></a>M:N关系(M个协程绑定1个线程, 是N:1和1:1类型的结合, 但是难以实现)</h4><p><img src="co-routine-5.png" alt="co-routine-5"><br>协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。</p>
<h3 id="Go语言的协程-goroutine"><a href="#Go语言的协程-goroutine" class="headerlink" title="Go语言的协程(goroutine)"></a>Go语言的协程(goroutine)</h3><p>Go为了提供更容易使用的并发方法，使用了<code>goroutine</code>和<code>channel</code>。<br>goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。<br>最关键的是，<strong>程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发</strong>。<br>Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。<br>虽然一个goroutine的栈只占几KB，但实际是<strong>可伸缩的</strong>，如果需要更多内容，<code>runtime</code>会自动为goroutine分配。<br>Goroutine特点：</p>
<ul>
<li>占用内存更小（几kb）</li>
<li>调度更灵活(<code>runtime</code>调度)</li>
</ul>
<h3 id="被废弃的goroutine调度器"><a href="#被废弃的goroutine调度器" class="headerlink" title="被废弃的goroutine调度器"></a>被废弃的goroutine调度器</h3><p>既然我们知道了<code>协程</code>和<code>线程</code>的关系，那么最关键的一点就是调度协程的调度器的实现了。<br>Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了。<br>那么我们先来分析一下被废弃的调度器是如何运作的？</p>
<p>大部分文章都是会用<code>G</code>来表示Goroutine，用<code>M</code>来表示线程(OS Thread)，那么我们也会用这种表达的对应关系。<br><img src="go-schd-old-1.png" alt="go-schd-old-1"><br>下面我们来看看被废弃的golang调度器是如何实现的<br><img src="go-schd-old-2.png" alt="go-schd-old-2"><br><code>M</code>想要执行、放回<code>G</code>都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局<code>G</code>队列是有互斥锁进行保护的。<br>老调度器有几个缺点：</p>
<ul>
<li>创建、销毁、调度<code>G</code>都需要每个<code>M</code>获取锁，这就形成了激烈的锁竞争。</li>
<li><code>M</code>转移<code>G</code>会造成延迟和额外的系统负载。比如当<code>G</code>中包含创建新协程的时候，<code>M</code>创建了<code>G2</code>，为了继续执行<code>G</code>，需要把<code>G2</code>交给<code>M2</code>执行，也造成了很差的局部性，因为<code>G2</code>和<code>G</code>是相关的，最好放在<code>M</code>上执行，而不是<code>M2</code>上。</li>
<li>系统调用(CPU在<code>M</code>之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ul>
<h2 id="二、Goroutine调度器的GMP模型的设计思想"><a href="#二、Goroutine调度器的GMP模型的设计思想" class="headerlink" title="二、Goroutine调度器的GMP模型的设计思想"></a>二、Goroutine调度器的GMP模型的设计思想</h2><p>面对之前调度器的问题，Go设计了新的调度器。<br>在新调度器中，出列M(thread)和G(goroutine)，又引入了P(Processor)。<br><img src="go-schd-1.png" alt="go-schd-1.png"><br><strong>Processor包含了运行goroutine的资源</strong>，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p>
<h3 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h3><p>在Go中，<strong>线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上</strong>。<br><img src="go-schd-2.png" alt="go-schd-2.png"><br><strong>全局队列（Global Queue）</strong>：存放等待运行的G。<br><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过<strong>256</strong>个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。<br><strong>P列表</strong>：所有的P都在程序启动时创建，并保存在数组中，最多有<code>GOMAXPROCS</code>(可配置)个。<br><strong>M</strong>：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。<br>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行。</p>
<p><strong>P和M的个数问题</strong></p>
<ul>
<li>P的数量<ul>
<li>由启动时环境变量<code>GOMAXPROCS</code>或者是由<code>runtime</code>的方法<code>GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有<code>GOMAXPROCS</code>个goroutine在同时运行。</li>
</ul>
</li>
<li>M的数量<ul>
<li>go语言本身的限制：go程序启动时，会设置M的最大数量，默认<strong>10000</strong>。但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li>
<li><code>runtime/debug</code>中的<code>SetMaxThreads</code>函数，设置<code>M</code>的最大数量</li>
<li>一个<code>M</code>阻塞了，会创建新的<code>M</code><br><code>M</code>与<code>P</code>的数量没有绝对关系，一个<code>M</code>阻塞，<code>P</code>就会去创建或者切换另一个<code>M</code>，所以，即使<code>P</code>的默认数量是<strong>1</strong>，也有可能会创建很多个<code>M</code>出来。</li>
</ul>
</li>
</ul>
<p><strong>P和M何时会被创建</strong></p>
<ul>
<li><strong>P</strong>，在确定了<code>P</code>的最大数量n后，运行时系统会根据这个数量创建n个<code>P</code>。</li>
<li><strong>M</strong>，没有足够的<code>M</code>来关联<code>P</code>并运行其中的可运行的<code>G</code>。比如所有的<code>M</code>此时都阻塞住了，而<code>P</code>中还有很多就绪任务，就会去寻找空闲的<code>M</code>，而没有空闲的，就会去创建新的<code>M</code>。</li>
</ul>
<h3 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h3><ul>
<li><strong>复用线程</strong>(避免频繁的创建、销毁线程，而是对线程的复用)<ul>
<li><strong>work stealing机制</strong>，当本线程无可运行的<code>G</code>时，尝试从其他线程绑定的<code>P</code>偷取<code>G</code>，而不是销毁线程。</li>
<li><strong>hand off机制</strong>，当本线程因为<code>G</code>进行系统调用阻塞时，线程释放绑定的<code>P</code>，把<code>P</code>转移给其他空闲的线程执行。</li>
</ul>
</li>
<li><strong>利用并行</strong><ul>
<li><code>GOMAXPROCS</code>设置<code>P</code>的数量，最多有<code>GOMAXPROCS</code>个线程分布在多个CPU上同时运行。</li>
<li><code>GOMAXPROCS</code>也限制了并发的程度，比如<code>GOMAXPROCS</code> = 核数/2，则最多利用了一半的CPU核进行并行。</li>
</ul>
</li>
<li><strong>抢占</strong><ul>
<li>在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</li>
</ul>
</li>
<li><strong>全局G队列</strong><ul>
<li>在新的调度器中依然有全局<code>G</code>队列，但功能已经被弱化了，当<code>M</code>执行work stealing从其他<code>P</code>偷不到<code>G</code>时，它可以从全局<code>G</code>队列获取<code>G</code>。</li>
</ul>
</li>
</ul>
<h3 id="go-func-调度流程"><a href="#go-func-调度流程" class="headerlink" title="go func() 调度流程"></a>go func() 调度流程</h3><p><img src="go-schd-3.png" alt="go-schd-3.png"><br>从上图我们可以分析出几个结论：</p>
<ol>
<li>我们通过 <code>go func()</code>来创建一个goroutine；</li>
<li>有两个存储<code>G</code>的队列，一个是局部调度器<code>P</code>的本地队列、一个是全局<code>G</code>队列。新创建的<code>G</code>会先保存在<code>P</code>的本地队列中，如果<code>P</code>的本地队列已经满了就会保存在全局的队列中；</li>
<li><code>G</code>只能运行在<code>M</code>中，一个<code>M</code>必须持有一个<code>P</code>，<code>M</code>与<code>P</code>是1：1的关系。<code>M</code>会从<code>P</code>的本地队列弹出一个可执行状态的<code>G</code>来执行，如果<code>P</code>的本地队列为空，就会想其他的<code>MP</code>组合偷取一个可执行的<code>G</code>来执行； </li>
<li>一个<code>M</code>调度<code>G</code>执行的过程是一个循环机制；</li>
<li>当<code>M</code>执行某一个<code>G</code>时候如果发生了<code>syscall</code>或则其余阻塞操作，<code>M</code>会阻塞，如果当前有一些<code>G</code>在执行，<code>runtime</code>会把这个线程<code>M</code>从<code>P</code>中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个<code>P</code>； </li>
<li>当<code>M</code>系统调用结束时候，这个<code>G</code>会尝试获取一个空闲的<code>P</code>执行，并放入到这个<code>P</code>的本地队列。如果获取不到<code>P</code>，那么这个线程<code>M</code>变成休眠状态， 加入到空闲线程中，然后这个<code>G</code>会被放入全局队列中。</li>
</ol>
<h3 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h3><p><img src="go-schd-4.png" alt="go-schd-4.png"><br><strong>M0</strong><br><code>M0</code>是启动程序后的编号为0的主线程，这个<code>M</code>对应的实例会在全局变量<code>runtime.m0</code>中，不需要在heap上分配，<code>M0</code>负责执行初始化操作和启动第一个<code>G</code>， 在之后<code>M0</code>就和其他的<code>M</code>一样了。<br><strong>G0</strong><br><code>G0</code>是每次启动一个<code>M</code>都会第一个创建的gourtine，<code>G0</code>仅用于负责调度的<code>G</code>，<code>G0</code>不指向任何可执行的函数, 每个<code>M</code>都会有一个自己的<code>G0</code>。在调度或系统调用时会使用<code>G0</code>的栈空间, 全局变量的<code>G0</code>是<code>M0</code>的<code>G0</code>。</p>
<p>我们来跟踪一段代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们来针对上面的代码对调度器里面的结构做一个分析, 也会经历如上图所示的过程：</p>
<ol>
<li><code>runtime</code>创建最初的线程<code>M0</code>和<code>G0</code>，并把两者关联。</li>
<li>调度器初始化：初始化<code>M0</code>、栈、垃圾回收，以及创建和初始化由<code>GOMAXPROCS</code>个<code>P</code>构成的<code>P</code>列表。</li>
<li>示例代码中的<code>main</code>函数是<code>main.main</code>，<code>runtime</code>中也有个<code>main</code>函数(<code>runtime.main</code>)，代码经过编译后，<code>runtime.main</code>会调用<code>main.main</code>，程序启动时会为<code>runtime.main</code>创建goroutine，称它为main goroutine吧，然后把main goroutine加入到<code>P</code>的本地队列。</li>
<li>启动<code>M0</code>，<code>M0</code>已经绑定了<code>P</code>，会从<code>P</code>的本地队列获取<code>G</code>，获取到main goroutine。</li>
<li><code>G</code>拥有栈，<code>M</code>根据<code>G</code>中的栈信息和调度信息设置运行环境</li>
<li><code>M</code>运行<code>G</code></li>
<li><code>G</code>退出，再次回到<code>M</code>获取可运行的<code>G</code>，这样重复下去，直到<code>main.main</code>退出，<code>runtime.main</code>执行Defer和Panic处理，或调用<code>runtime.exit</code>退出程序。<br>调度器的生命周期几乎占满了一个GO程序的一生，<code>runtime.main</code>的goroutine执行之前都是为调度器做准备工作，<code>runtime.main</code>的goroutine运行，才是调度器的真正开始，直到<code>runtime.main</code>结束而结束。</li>
</ol>
<h3 id="可视化GMP编程"><a href="#可视化GMP编程" class="headerlink" title="可视化GMP编程"></a>可视化GMP编程</h3><p>有2种方式可以查看一个程序的GMP的数据</p>
<h4 id="方式1：go-tool-trace"><a href="#方式1：go-tool-trace" class="headerlink" title="方式1：go tool trace"></a>方式1：go tool trace</h4><p>trace记录了运行时的信息，能提供可视化的Web页面。<br>简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印”Hello World”退出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建trace文件</span></span><br><span class="line">    f, err := os.Create(<span class="string">&quot;trace.out&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动trace goroutine</span></span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run trace.go </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<p>会得到一个trace.out文件，然后我们可以用一个工具打开，来分析这个文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go tool trace trace.out </span><br><span class="line">2020/02/23 10:44:11 Parsing trace...</span><br><span class="line">2020/02/23 10:44:11 Splitting trace...</span><br><span class="line">2020/02/23 10:44:11 Opening browser. Trace viewer is listening on http://127.0.0.1:33479</span><br></pre></td></tr></table></figure>
<p>我们可以通过浏览器打开<a href="http://127.0.0.1:33479网址，点击view">http://127.0.0.1:33479网址，点击view</a> trace 能够看见可视化的调度流程。<br><img src="trace-1.png" alt="trace-1"><br><img src="trace-2.png" alt="trace-2"></p>
<p><strong>G信息</strong>：点击Goroutines那一行可视化的数据条，我们会看到一些详细的信息。<br><img src="trace-3.png" alt="trace-3"><br><em>一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论</em><br>其中G1应该就是main goroutine(执行main函数的协程)，在一段时间内处于可运行和运行的状态。</p>
<p><strong>M信息</strong>：点击Threads那一行可视化的数据条，我们会看到一些详细的信息。<br><img src="trace-4.png" alt="trace-4"><br><em>一共有两个M在程序中，一个是特殊的M0，用于初始化使用，这个我们不必讨论</em><br><img src="trace-5.png" alt="trace-5"><br>G1中调用了main.main，创建了trace goroutine G18。G1运行在P1上，G18运行在P0上。<br>这里有两个P，我们知道，一个P必须绑定一个M才能调度G。<br>我们在来看看上面的M信息。<br><img src="trace-6.png" alt="trace-6"><br>我们会发现，确实G18在P0上被运行的时候，确实在Threads行多了一个M的数据，点击查看如下：<br><img src="trace-7.png" alt="trace-7"><br>多了一个M2应该就是P0为了执行G18而动态创建的M2.</p>
<h4 id="方式2：Debug-trace"><a href="#方式2：Debug-trace" class="headerlink" title="方式2：Debug trace"></a>方式2：Debug trace</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build trace2.go</span><br></pre></td></tr></table></figure>
<p>通过Debug方式运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ GODEBUG=schedtrace=1000 ./trace2 </span><br><span class="line">SCHED 0ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1 idlethreads=1 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 1003ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 2014ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 3015ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 4023ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<p><code>SCHED</code>：调试信息输出标志字符串，代表本行是goroutine调度器的输出；<br><code>0ms</code>：即从程序启动到输出这行日志的时间；<br><code>gomaxprocs</code>: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；<br><code>idleprocs</code>: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；<br><code>threads</code>: os threads/M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；<br><code>spinningthreads</code>: 处于自旋状态的os thread数量；<br><code>idlethread</code>: 处于idle状态的os thread的数量；<br><code>runqueue=0</code>： Scheduler全局队列中G的数量；<br><code>[0 0]</code>: 分别为2个P的local queue中的G的数量。</p>
<h2 id="三、Go调度器调度场景过程全解析"><a href="#三、Go调度器调度场景过程全解析" class="headerlink" title="三、Go调度器调度场景过程全解析"></a>三、Go调度器调度场景过程全解析</h2><h3 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h3><p>P拥有G1，M1获取P后开始运行G1，G1使用go func()创建了G2，为了局部性G2优先加入到P1的本地队列。<br><img src="scene-1.png" alt="scene-1"></p>
<h3 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h3><p>G1运行完成后(函数：<code>goexit</code>)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：<code>schedule</code>）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：<code>execute</code>)。实现了线程M1的复用。<br><img src="scene-2.png" alt="scene-2"></p>
<h3 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h3><p>假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入P1的本地队列，P1本地队列满了。<br><img src="scene-3.png" alt="scene-3"></p>
<h3 id="场景4"><a href="#场景4" class="headerlink" title="场景4"></a>场景4</h3><p>G2在创建G7的时候，发现P1的本地队列已满，需要执行负载均衡(把P1中本地队列中前一半的G，还有新创建G转移到全局队列)<br><em>实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列</em><br><img src="scene-4.png" alt="scene-4"><br>这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。</p>
<h3 id="场景5"><a href="#场景5" class="headerlink" title="场景5"></a>场景5</h3><p>G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。<br><img src="scene-5.png" alt="scene-5"><br>G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。</p>
<h3 id="场景6"><a href="#场景6" class="headerlink" title="场景6"></a>场景6</h3><p>规定：在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行。<br><img src="scene-6.png" alt="scene-6"><br>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程（没有G但为运行状态的线程，不断寻找G）。</p>
<h3 id="场景7"><a href="#场景7" class="headerlink" title="场景7"></a>场景7</h3><p>M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：findrunnable()）。<br>M2从全局队列取的G数量符合下面的公式：<code>n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))</code><br>至少从全局队列取1个G，但每次不要从全局队列移动太多的G到P本地队列，给其他P留点。这是<strong>从全局队列到P本地队列的负载均衡</strong>。<br><img src="scene-7.png" alt="scene-7"><br>假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。</p>
<h3 id="场景8"><a href="#场景8" class="headerlink" title="场景8"></a>场景8</h3><p>假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。<br><img src="scene-8.png" alt="scene-8"><br>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。</p>
<h3 id="场景9"><a href="#场景9" class="headerlink" title="场景9"></a>场景9</h3><p>G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于自旋状态，它们不断寻找goroutine。<br><img src="scene-9.png" alt="scene-9"><br>为什么要让M3和M4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU。<br>为什么不销毁现场，来节约CPU资源。<br>因为创建和销毁CPU也会浪费时间，我们希望当有新goroutine创建时，立刻能有M运行它，如果销毁再新建就增加了时延，降低了效率。<br>当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有<code>GOMAXPROCS</code>个自旋的线程(当前例子中的<code>GOMAXPROCS</code>=4，所以一共4个P)，多余的没事做线程会让他们休眠。</p>
<h3 id="场景10"><a href="#场景10" class="headerlink" title="场景10"></a>场景10</h3><p>假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;=P, 大部分都是M在抢占需要运行的P)，<br>G8创建了G9，G8进行了阻塞的系统调用，M2和P2立即解绑，<br>P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。<br>本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。<br><img src="scene-10.png" alt="scene-10"></p>
<h3 id="场景11"><a href="#场景11" class="headerlink" title="场景11"></a>场景11</h3><p>G8创建了G9，假如G8进行了非阻塞系统调用。<br><img src="scene-11.png" alt="scene-11"><br>M2和P2会解绑，但M2会记住P2，然后G8和M2进入系统调用状态。<br>当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，<br>如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。<br><strong>Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发</strong>。</p>
<h2 id="相关好博客推荐"><a href="#相关好博客推荐" class="headerlink" title="相关好博客推荐"></a>相关好博客推荐</h2><ul>
<li><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">Scheduling In Go: Part I - OS Scheduler</a></li>
<li><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">Scheduling In Go : Part II - Go Scheduler</a></li>
<li><a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html">Scheduling In Go : Part III - Concurrency</a></li>
</ul>
<p><strong>原文作者:</strong> <a href="https://segmentfault.com/u/aceld">刘丹冰 Aceld</a><br><strong>原文地址:</strong> <a href="https://segmentfault.com/a/1190000021951119">Golang三色标记、混合写屏障GC模式图文全分析</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>面试题</tag>
        <tag>goroutine</tag>
        <tag>gmp</tag>
      </tags>
  </entry>
  <entry>
    <title>redis常见面试题</title>
    <url>/2021/02/05/redis-interview/</url>
    <content><![CDATA[<h1 id="Redis常见的数据结构？"><a href="#Redis常见的数据结构？" class="headerlink" title="Redis常见的数据结构？"></a>Redis常见的数据结构？</h1><blockquote>
<p>String、Hash、List、Set、ZSet</p>
</blockquote>
<h2 id="String-字符串类型"><a href="#String-字符串类型" class="headerlink" title="String 字符串类型"></a>String 字符串类型</h2><p>string类型是redis中最基本的数据类型，一个key对应一个value。<br>string类型是二进制安全的，意思是redis的string可以包含任何数据, 如数字, 字符串, jpg图片或者序列化的对象。<br><strong>实战场景：</strong></p>
<ul>
<li>缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li>
<li>计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</li>
<li>session：常见方案spring session + redis实现session共享</li>
</ul>
<h2 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h2><p>是一个Map，指值本身又是一种键值对结构，如 value=<code>&#123;&#123;field1,value1&#125;,......fieldN,valueN&#125;&#125;</code><br><strong>实战场景</strong></p>
<ul>
<li>缓存： 能直观，相比<strong>string更节省空间</strong>，的维护缓存信息，如用户信息，视频信息等。</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>List 说白了就是链表（redis 使用双端链表实现的 List），是有序的，value可以重复，可以通过下标取出对应的value值，左右两边都能进行插入和删除数据。<br><strong>使用列表的技巧</strong></p>
<ul>
<li>lpush+lpop=Stack(栈)</li>
<li>lpush+rpop=Queue（队列）</li>
<li>lpush+ltrim=Capped Collection（有限集合）</li>
<li>lpush+brpop=Message Queue（消息队列）</li>
</ul>
<p><strong>实战场景</strong></p>
<ul>
<li>timeline：例如微博的时间轴，有人发布微博，用lpush加入时间轴，展示新的列表信息。</li>
</ul>
<h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h2><p>集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中 </p>
<ul>
<li>不允许有重复的元素 </li>
<li>集合中的元素是无序的，不能通过索引下标获取元素</li>
<li>支持集合间的操作，可以取多个集合取交集、并集、差集。</li>
</ul>
<p><strong>实战场景</strong></p>
<ul>
<li>标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li>
<li>点赞，或点踩，收藏等，可以放到set中实现</li>
</ul>
<h2 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset 有序集合"></a>zset 有序集合</h2><p>有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性，区别是，有序集合中的元素是可以排序的，它给每个元素设置一个分数，作为排序的依据。</p>
<blockquote>
<p>有序集合中的元素不可以重复，但是score 分数 可以重复，就和一个班里的同学学号不能重复，但考试成绩可以相同</p>
</blockquote>
<p><strong>实战场景</strong></p>
<ul>
<li>排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li>
</ul>
<h1 id="Redis持久化的原理及优化"><a href="#Redis持久化的原理及优化" class="headerlink" title="Redis持久化的原理及优化"></a>Redis持久化的原理及优化</h1><blockquote>
<p><strong>原文作者:</strong> 大愚Talk<br><strong>原文地址:</strong> <a href="https://juejin.cn/post/6844903655527677960">一文看懂Redis的持久化原理</a></p>
</blockquote>
<p>Redis为持久化提供了两种方式：</p>
<ul>
<li><strong>RDB</strong>：在指定的时间间隔能对你的数据进行快照存储。</li>
<li><strong>AOF</strong>：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。</li>
</ul>
<p>本文将通过下面内容的介绍，希望能够让大家更全面、清晰的认识这两种持久化方式，同时理解这种保存数据的思路，应用于自己的系统设计中。</p>
<ul>
<li>持久化的配置 </li>
<li>RDB与AOF持久化的工作原理</li>
<li>如何从持久化中恢复数据</li>
<li>关于性能与实践建议</li>
</ul>
<h2 id="持久化的配置"><a href="#持久化的配置" class="headerlink" title="持久化的配置"></a>持久化的配置</h2><p>为了使用持久化的功能，我们需要先知道该如何开启持久化的功能。</p>
<h3 id="RDB的持久化配置"><a href="#RDB的持久化配置" class="headerlink" title="RDB的持久化配置"></a>RDB的持久化配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 时间策略</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件保存路径</span></span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果持久化出错，主进程是否停止写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否压缩</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入时是否检查</span></span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>
<p>配置其实非常简单，这里说一下持久化的时间策略具体是什么意思。</p>
<ul>
<li><code>save 900 1</code> 表示900s内如果有1条是写入命令，就触发产生一次快照，可以理解为就进行一次备份</li>
<li><code>save 300 10</code> 表示300s内有10条写入，就产生快照</li>
</ul>
<p>下面的类似，那么为什么需要配置这么多条规则呢？<br>因为Redis每个时段的读写请求肯定不是均衡的，为了平衡性能与数据安全，我们可以自由定制什么情况下触发备份。所以这里就是根据自身Redis写入情况来进行合理配置。</p>
<p><code>stop-writes-on-bgsave-error yes</code> 这个配置也是非常重要的一项配置，这是当备份进程出错时，主进程就停止接受新的写入操作，是为了保护持久化的数据一致性问题。<br><strong>如果自己的业务有完善的监控系统，可以禁止此项配置，否则请开启</strong></p>
<p>关于压缩的配置 <code>rdbcompression yes</code>，建议没有必要开启，毕竟Redis本身就属于CPU密集型服务器，再开启压缩会带来更多的CPU消耗，相比硬盘成本，CPU更值钱。</p>
<p>当然如果你想要禁用RDB配置，也是非常容易的，只需要在save的最后一行写上：<code>save &quot;&quot;</code></p>
<h3 id="AOF的配置"><a href="#AOF的配置" class="headerlink" title="AOF的配置"></a>AOF的配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 是否开启aof</span></span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件名称</span></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步方式</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> aof重写期间是否同步</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重写触发配置</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载aof时如果有错如何处理</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件重写策略</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>
<p>还是重点解释一些关键的配置：<br><code>appendfsync everysec</code> 它其实有三种模式:</p>
<ul>
<li><strong>always</strong>：把每个写命令都立即同步到aof，很慢，但是很安全</li>
<li><strong>everysec</strong>：每秒同步一次，是折中方案</li>
<li><strong>no</strong>：redis不处理交给OS来处理，非常快，但是也最不安全</li>
</ul>
<p>一般情况下都采用 <strong>everysec</strong> 配置，这样可以兼顾速度与安全，最多损失1s的数据。</p>
<p><code>aof-load-truncated yes</code> 如果该配置启用，在加载时发现aof尾部不正确时，会向客户端写入一个log，但是会继续执行<br>如果设置为 <code>no</code> ，发现错误就会停止，必须修复后才能重新加载。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>关于原理部分，我们主要来看RDB与AOF是如何完成持久化的，他们的过程是如何。</p>
<p>在介绍原理之前先说下Redis内部的定时任务机制，定时任务执行的频率可以在配置文件中通过 <code>hz 10</code> 来设置（这个配置表示1s内执行10次，也就是每100ms触发一次定时任务）。<br>该值最大能够设置为：<code>500</code>，但是不建议超过：<code>100</code>，因为值越大说明执行频率越频繁越高，这会带来CPU的更多消耗，从而影响主进程读写性能。</p>
<p>定时任务使用的是Redis自己实现的 <code>TimeEvent</code>，它会定时去调用一些命令完成定时任务，这些任务可能会阻塞主进程导致Redis性能下降。<br>因此我们在配置Redis时，一定要整体考虑一些会触发定时任务的配置，根据实际情况进行调整。</p>
<h3 id="RDB的原理"><a href="#RDB的原理" class="headerlink" title="RDB的原理"></a>RDB的原理</h3><p>在Redis中RDB持久化的触发分为两种：自己手动触发与Redis定时触发。<br><strong>针对RDB方式的持久化，手动触发可以使用：</strong></p>
<ul>
<li>save：会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用。</li>
<li>bgsave：该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候。</li>
</ul>
<p><strong>而自动触发的场景主要是有以下几点：</strong></p>
<ul>
<li>根据我们的 <code>save m n</code> 配置规则自动触发；</li>
<li>从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发 <code>bgsave</code>；</li>
<li>执行 <code>debug reload</code> 时；</li>
<li>执行 <code>shutdown</code>时，如果没有开启aof，也会触发。</li>
</ul>
<p>由于 <code>save</code> 基本不会被使用到，我们重点看看 <code>bgsave</code> 这个命令是如何完成RDB的持久化的。<br><img src="redis-1.png" alt="redis-1"><br>这里注意的是 <code>fork</code> 操作会阻塞，导致Redis读写性能下降。<br>我们可以控制单个Redis实例的最大内存，来尽可能降低Redis在fork时的事件消耗。<br>以及上面提到的自动触发的频率减少fork次数，或者使用手动触发，根据自己的机制来完成持久化。</p>
<h3 id="AOF的原理"><a href="#AOF的原理" class="headerlink" title="AOF的原理"></a>AOF的原理</h3><p>AOF的整个流程大体来看可以分为两步，一步是命令的实时写入（如果是 <code>appendfsync everysec</code> 配置，会有1s损耗），第二步是对aof文件的重写。</p>
<p>对于增量追加到文件这一步主要的流程是：命令写入-&gt;追加到aof_buf-&gt;同步到aof磁盘。<br>那么这里为什么要先写入buf在同步到磁盘呢？如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能。</p>
<p>aof重写是为了减少aof文件的大小，可以手动或者自动触发，关于自动触发的规则请看上面配置部分。<br>fork的操作也是发生在重写这一步，也是这里会对主进程产生阻塞。</p>
<ul>
<li>手动触发： <code>bgrewriteaof</code></li>
<li>自动触发 就是根据配置规则来触发，当然自动触发的整体时间还跟Redis的定时任务频率有关系。</li>
</ul>
<p>下面来看看重写的一个流程图：<br><img src="redis-2.png" alt="redis-2"><br>对于上图有四个关键点补充一下：</p>
<ul>
<li>在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；因此它依然会写入旧的AOF file中，如果重写失败，能够保证数据不丢失。</li>
<li>为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个buf，防止新写的file丢失数据。</li>
<li>重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。</li>
<li>AOF文件直接采用的文本协议，主要是兼容性好、追加方便、可读性高可认为修改修复。</li>
</ul>
<blockquote>
<p>不论是RDB还是AOF都是先写入一个临时文件，然后通过 rename 完成文件的替换工作。</p>
</blockquote>
<h2 id="从持久化中恢复数据"><a href="#从持久化中恢复数据" class="headerlink" title="从持久化中恢复数据"></a>从持久化中恢复数据</h2><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p>
<p>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：<br><img src="redis-3.png" alt="redis-3"><br>启动时会先检查AOF文件是否存在，如果不存在就尝试加载RDB。<br>那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p>
<h2 id="新能与实践"><a href="#新能与实践" class="headerlink" title="新能与实践"></a>新能与实践</h2><p>通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。</p>
<ul>
<li>降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；</li>
<li>控制Redis最大使用内存，防止fork耗时过长；</li>
<li>使用更牛逼的硬件；</li>
<li>合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。</li>
</ul>
<p>在线上我们到底该怎么做？我提供一些自己的实践经验。</p>
<ul>
<li>如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；</li>
<li>自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；</li>
<li>单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；</li>
<li>可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；</li>
<li>RDB持久化与AOF持久化可以同时存在，配合使用。</li>
</ul>
<p>本文的内容主要是运维上的一些注意点，但我们开发者了解到这些知识，在某些时候有助于我们发现诡异的bug。</p>
<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><blockquote>
<p><strong>原文作者:</strong> 原来是咔咔<br><strong>原文地址:</strong> <a href="https://juejin.cn/post/6844904178519654414">写给大忙人的Redis主从复制，花费五分钟让你面试不尴尬</a><br>相信很多小伙伴都已经配置过主从复制，但是对于redis主从复制的工作流程和常见问题很多都没有深入的了解。</p>
</blockquote>
<h2 id="什么是Redis主从复制"><a href="#什么是Redis主从复制" class="headerlink" title="什么是Redis主从复制"></a>什么是Redis主从复制</h2><p>主从复制就是现在有俩台redis服务器，把一台redis的数据同步到另一台redis数据库上。<br>前者称之为主节点（master），后者为从节点（slave）。<br>数据是只能master往slave同步单向。</p>
<p>但是在实际过程中是不可能只有俩台redis服务器来做主从复制的，这也就意味这每台redis服务器都有可能会称为主节点（master）</p>
<p>下图案例中，我们的slave3既是master的从节点，也是slave的主节点。<br><img src="redis-4.png" alt="redis-4"><br>先知道这么个概念，更多详解继续查看下文。</p>
<h2 id="为什么需要Redis主从复制"><a href="#为什么需要Redis主从复制" class="headerlink" title="为什么需要Redis主从复制"></a>为什么需要Redis主从复制</h2><p>假设我们现在就一台redis服务器，也就是单机状态。<br>在这种情况下会出现的第一个问题就是服务器宕机，直接导致数据丢失。如果项目是跟￥占关系的，那造成的后果就可想而知。<br>第二个情况就是内存问题了，当只有一台服务器时内存肯定会到达峰值的，不可能对一台服务器进行无限升级的。<br>所以针对以上俩个问题，我们就多准备几台服务器，配置主从复制。<br>将数据保存在多个服务器上,并且保证每个服务器的数据是同步的。<br>即使有一个服务器宕机了，也不会影响用户的使用。redis可以继续实现高可用、同时实现数据的冗余备份。<br><img src="redis-5.png" alt="redis-5"><br>这会应该会有很多疑问，master跟slave怎么连接呢？ 如何同步数据呢？ 假如master服务器宕机了呢？别着急，一点一点解决你的问题。</p>
<h2 id="Redis主从复制的作用"><a href="#Redis主从复制的作用" class="headerlink" title="Redis主从复制的作用"></a>Redis主从复制的作用</h2><p>在上边我们说了为什么使用redis的主从复制，那么主从复制的作用就是针对为什么使用它来讲了。<br>我们继续使用这个图来谈论<br><img src="redis-5.png" alt="redis-5"></p>
<ul>
<li>第一点是数据冗余了，实现了数据的热备份，是持久化之外的另一种方式。</li>
<li>第二点是针对单机故障问题。当主节点也就是master出现问题时，可以由从节点来提供服务也就是slave，实现了快速恢复故障，也就是服务冗余。</li>
<li>第三点是读写分离，master服务器主要是写，slave主要用来读数据，可以提高服务器的负载能力。同时可以根据需求的变化，添加从节点的数量。</li>
<li>第四点是负载均衡，配合读写分离，有主节点提供写服务，从节点提供读服务，分担服务器负载，尤其在写少读多的情况下，通过多个从节点分担读负载，可以大大提高redis服务器的并发量和负载。</li>
<li>第五点是高可用的基石，主从复制是哨兵和集群能够实施的基础，因此我们可以说主从复制是高可用的基石。</li>
</ul>
<h2 id="配置Redis主从复制"><a href="#配置Redis主从复制" class="headerlink" title="配置Redis主从复制"></a>配置Redis主从复制</h2><p>从redis：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">slave-serve-stale-data yes  // 默认就是开启的，当slave和master断开链接时，slave依旧会返回数据</span><br><span class="line">slave-read-only yes // 默认只读</span><br></pre></td></tr></table></figure>
<h2 id="主从复制工作原理"><a href="#主从复制工作原理" class="headerlink" title="主从复制工作原理"></a>主从复制工作原理</h2><h3 id="主从复制的三个阶段"><a href="#主从复制的三个阶段" class="headerlink" title="主从复制的三个阶段"></a>主从复制的三个阶段</h3><p>主从复制完整的工作流程分为以下三个阶段。每一段都有自己的内部工作流程，那么我们会对这三个过程进行谈论。</p>
<ul>
<li>建立连接过程：这个过程就是slave跟master连接的过程</li>
<li>数据同步过程：是master给slave同步数据的过程</li>
<li>命令传播过程：是反复同步数据<br><img src="redis-6.png" alt="redis-6"></li>
</ul>
<h3 id="第一阶段：建立连接过程"><a href="#第一阶段：建立连接过程" class="headerlink" title="第一阶段：建立连接过程"></a>第一阶段：建立连接过程</h3><p><img src="redis-7.png" alt="redis-7"><br>上图是一个完整主从复制建立连接工作流程。然后使用简短的话语来描述上边的工作流程。</p>
<ul>
<li>设置master的地址和端口，保存master的信息</li>
<li>建立socket连接（这个连接做的事情下文会说）</li>
<li>持续发送ping命令</li>
<li>身份验证</li>
<li>发送slave端口信息</li>
</ul>
<p>在建立连接的过程中，从节点会保存master的地址和端口、主节点master保存从节点slave的端口。</p>
<h3 id="第二阶段：数据同步阶段过程"><a href="#第二阶段：数据同步阶段过程" class="headerlink" title="第二阶段：数据同步阶段过程"></a>第二阶段：数据同步阶段过程</h3><p><img src="redis-8.png" alt="redis-8"><br>这张图是详细描述第一次从节点连接主节点时的数据同步过程。<br>当从节点第一次连接主节点时，先会执行一次全量复制这次的全量复制是无法避免的。<br>全量复制执行完成后，主节点就会发送复制积压缓冲区的数据，然后从节点就会执行bgrewriteaof恢复数据，这也就是部分复制。<br>在这个阶段提到了三个新点，全量复制、部分复制、复制缓冲积压区。会在下文的常见问题里详细说明这几个点。</p>
<h3 id="第三阶段：命令传播阶段"><a href="#第三阶段：命令传播阶段" class="headerlink" title="第三阶段：命令传播阶段"></a>第三阶段：命令传播阶段</h3><p>当master数据库被修改后，主从服务器的数据不一致后，此时就会让主从数据同步到一致，这个过程称之为命令传播。<br>master会将接收到的数据变更命令发送给slave，slave接收命令后执行命令，让主从数据达到一致。<br><strong>命令传播阶段的部分复制</strong></p>
<ul>
<li>在命令传播阶段出现断网的情况，或者网络抖动时会导致连接断开（connection  lost）</li>
<li>这个时候主节点master还是会继续往replbackbuffer（复制缓冲积压区）写数据</li>
<li>从节点会继续尝试连接主机（connect to master）</li>
<li>当从节点把自己的runid和复制偏移量发送给主节点，并且执行pysnc命令同步</li>
<li>如果master判断偏移量是在复制缓冲区范围内，就会返回continue命令。并且发送复制缓冲区的数据给从节点。</li>
<li>从节点接收数据执行bgrewriteaof，恢复数据</li>
</ul>
<h2 id="详细介绍主从复制原理（全量复制-部分复制）"><a href="#详细介绍主从复制原理（全量复制-部分复制）" class="headerlink" title="详细介绍主从复制原理（全量复制+部分复制）"></a>详细介绍主从复制原理（全量复制+部分复制）</h2><p><img src="redis-9.png" alt="redis-9"><br>这个过程就是主从复制最齐全的流程讲解。那么下来我们对每一步进程简单的介绍</p>
<ul>
<li>从节点发送指令<code>psync ? 1 psync runid offset</code>找对应的runid索取数据。但是这里可以考虑一下，当从节点第一次连接的时候根本就不知道主节点的<code>runid</code>和<code>offset</code>。所以第一次发送的指令是<code>psync ？ 1</code>意思就是主节点的数据我全要。</li>
<li>主节点开始执行bgsave生成RDB文件，记录当前的复制偏移量offset</li>
<li>主节点这个时候会把自己的<code>runid</code>和<code>offset</code>通过 +FULLRESYNC runid offset 指令 通过socket发送RDB文件给从节点。</li>
<li>从节点接收到+FULLRESYNC 保存主节点的<code>runid</code>和<code>offset</code>然后清空当前所有数据，通过socket接收RDB文件，开始恢复RDB数据。</li>
<li>在全量复制后，从节点已经获取到了主节点的<code>runid</code>和<code>offset</code>，开始发送指令<code>psync runid offset</code></li>
<li>主节点接收指令，判断<code>runid</code>是否匹配，判断<code>offset</code>是否在复制缓冲区中。</li>
<li>主节点判断<code>runid</code>和<code>offset</code>有一个不满足，就会在返回到步骤2继续执行全量复制。这里的<code>runid</code>不匹配只有的可能是从节点重启了这个问题后边会解决，offset（偏移量）不匹配就是复制积压缓冲区溢出了。 如果runid或offset校验通过，从节点的offset和主节点的offset相同时则忽略。 如果runid或offset检验通过，从节点的offset与offset不相同，则会发送 +CONTINUE  offset(这个offset为主节点的)，通过socket发送复制缓冲区中从节点offset到主节点offset的数据。</li>
<li>从节点收到+CONTINUE 保存master的offset 通过socket接收到信息后，执行bgrewriteaof，恢复数据。</li>
</ul>
<p>1-4是全量复制 5-8是部分复制<br>在主节点的第3步下面 主节点在主从复制的期间是一直在接收客户端的数据，主节点的offset是一直变化的。<br>只有有变化就会给每个slave进行发送，这个发送的过程称之为心跳机制</p>
<h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><p>在命令传播阶段是，主节点与从节点之间一直都需要进行信息互换，使用心跳机制进行维护，实现主节点和从节点连接保持在线。<br><strong>master心跳</strong></p>
<ul>
<li>指令：ping </li>
<li>默认10秒进行一次，是由参数repl-ping-slave-period决定的</li>
<li>主要做的事情就是判断从节点是否在线</li>
<li>可以使用info replication 来查看从节点租后一次连接时间的间隔，lag为0或者为1就是正常状态。</li>
</ul>
<p><strong>slave心跳任务</strong></p>
<ul>
<li>指令：replconf ack {offset}</li>
<li>每秒执行一次</li>
<li>主要做的事情是给主节点发送自己的复制偏移量，从主节点获取到最新的数据变更命令，还做一件事情就是判断主节点是否在线。</li>
</ul>
<p><strong>心跳阶段的注意事项</strong><br>主节点为保障数据稳定性，当从节点挂掉的数量或者延迟过高时。将会拒绝所有信息同步。<br>这里有俩个参数可以进行配置调整：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 2</span><br><span class="line">min-slaves-max-lag 8</span><br></pre></td></tr></table></figure>
<p>这俩个参数表示从节点的数量就剩余2个，或者从节点的延迟大于8秒时，主节点就会强制关闭master功能，停止数据同步。<br>那么主节点是如何知道从节点挂掉的数量和延迟时间呢！<br>在心跳机制里边slave 会每隔一秒发送perlconf ack 这个指令，这个指令可携带偏移量，也可以携带从节点的延迟时间和从节点的数量。</p>
<h2 id="部分复制的三个核心要素"><a href="#部分复制的三个核心要素" class="headerlink" title="部分复制的三个核心要素"></a>部分复制的三个核心要素</h2><h3 id="服务器的运行id（run-id）"><a href="#服务器的运行id（run-id）" class="headerlink" title="服务器的运行id（run id）"></a>服务器的运行id（run id）</h3><p>我们先看一下这个run id是什么，执行info命令即可看到。在上文中我们查看启动日志信息也可以看到。<br><img src="redis-11.png" alt="redis-11"><br>redis在启动时会自动生成一个随机的id（这里需要注意的是每次启动的id都会不一样），是由40个随机的十六进制字符串组成，用来唯一识别一个redis节点。<br>在主从复制初次启动时，master会把自己的runid发送给slave，slave会保存master的这个id，我们可以使用info命令查看<br><img src="redis-12.png" alt="redis-12"><br>当断线重连时，slave把这个id发送给master，如果slave保存的runid与master现在的runid相同，master会尝试使用部分复制（这块能否复制成功还有一个因素就是偏移量）。<br>如果slave保存的runid与master现在的runid不同，则会直接进行全量复制。</p>
<h3 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h3><p>复制缓冲积压区是一个先进先出的队列，用户存储master收集数据的命令记录。复制缓冲区的默认存储空间是1M。<br>可以在配置文件修改<code>repl-backlog-size 1mb</code>来控制缓冲区大小，这个比例可以根据自己的服务器内存来修改。<br><strong>复制缓冲区到底存储的是什么？</strong><br>复制积压缓冲区就是存储的aof持久化的数据，并且以字节分开，并且每个字节都有自己的偏移量。这个偏移量也就是复制偏移量（offset）<br><img src="redis-13.png" alt="redis-13"><br><strong>那为什么会说复制缓冲积压区有可能会导致全量复制呢</strong><br>在命令传播阶段，主节点会把收集的数据存储到复制缓冲区中，然后在发送给从节点。<br>就是这里出现了问题，当主节点数据量在一瞬间特别大的时候，超出了复制缓冲区的内存，就会有一部分数据会被挤出去，从而导致主节点和从节点的数据不一致。<br>从而进行全量复制。如果这个缓冲区大小设置不合理那么很大可能会造成死循环，从节点就会一直全量复制，清空数据，全量复制。</p>
<h3 id="复制偏移量（offset）"><a href="#复制偏移量（offset）" class="headerlink" title="复制偏移量（offset）"></a>复制偏移量（offset）</h3><p><img src="redis-14.png" alt="redis-14"><br>主节点复制偏移量是给从节点发送一次记录一次，从节点是接收一次记录一次。<br>用于同步信息，对比主节点和从节点的差异，当slave断联时恢复数据使用。<br>这个值也就是来自己于复制缓冲积压区里边的那个偏移量。</p>
<h2 id="主从复制常见的问题"><a href="#主从复制常见的问题" class="headerlink" title="主从复制常见的问题"></a>主从复制常见的问题</h2><h3 id="主节点重启问题（内部优化）"><a href="#主节点重启问题（内部优化）" class="headerlink" title="主节点重启问题（内部优化）"></a>主节点重启问题（内部优化）</h3><p>当主节点重启后，runid的值将发生变化，会导致所有的从节点进行全量复制。<br>这个问题我们无需考虑，知道系统是怎么优化的即可。<br>在建立完主从复制后主节点会创建master-replid变量，这个生成的策略跟runid一样，长度是41位，runid长度是40位，然后发送给从节点。<br><img src="redis-10.png" alt="redis-10"><br>在主节点执行shutdown save命令时，进行了一次RDB持久化会把runid 和 offset保存到RDB文件中。可以使用命令redis-check-rdb查看该信息。</p>
<h3 id="从节点网络中断偏移量越界导致全量复制"><a href="#从节点网络中断偏移量越界导致全量复制" class="headerlink" title="从节点网络中断偏移量越界导致全量复制"></a>从节点网络中断偏移量越界导致全量复制</h3><p>由于网络环境不佳，从节点网络中断。复制积压缓冲区内存过小导致数据溢出，伴随着从节点偏移量越界，导致全量复制。有可能会导致反复的全量复制。<br><strong>解决方案</strong>：修改复制积压缓冲区的大小：repl-backlog-size<br><strong>设置建议</strong>：测试主节点连接从节点的时间，获取主节点每秒平均产生的命令总量write_size_per_second<br>复制缓冲区空间设置 = 2 * 主从连接时间 * 主节点每秒产生的数据总量</p>
<h3 id="频繁的网路中断"><a href="#频繁的网路中断" class="headerlink" title="频繁的网路中断"></a>频繁的网路中断</h3><p>由于主节点的cpu占用过高，或者从节点频繁连接。出现这种情况造成的结果就是主节点各种资源被严重占用，其中包括但不限于缓冲区，宽带，连接等。<br>为什么会出现主节点资源被严重占用？<br>在心跳机制中，从节点每秒会发送一个指令replconf ack指令到主节点。<br>从节点执行了慢查询，占用大量的cpu<br>主节点每秒调用复制定时函数replicationCron，然后从节点长时间没有相应。</p>
<p><strong>解决方案</strong>：<br>设置从节点超时释放<br><strong>设置参数</strong>：repl-timeout<br>这个参数默认为60秒。超过60秒，释放slave。</p>
<h3 id="数据不一致问题"><a href="#数据不一致问题" class="headerlink" title="数据不一致问题"></a>数据不一致问题</h3><p>由于网络因素，多个从节点的数据会不一致。这个因素是没有办法避免的。<br>关于这个问题给出俩个解决方案：<br>第一个数据需要高度一致配置一台redis服务器，读写都用一台服务器，这种方式仅限于少量数据，并且数据需高度一直。<br>第二个监控主从节点的偏移量，如果从节点的延迟过大，暂时屏蔽客户端对该从节点的访问。<br>设置参数为slave-serve-stale-data  yes|no。这个参数一但设置就只能响应info slaveof等少数命令。</p>
<h3 id="从节点故障"><a href="#从节点故障" class="headerlink" title="从节点故障"></a>从节点故障</h3><p>这个问题直接在客户端维护一个可用节点列表，当从节点故障时，切换到其他节点进行工作，这个问题在后边集群会说到。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要讲解了什么是主从复制、主从复制工作的三大阶段以及工作流程、部分复制的三大核心。<br>命令传播阶段的心跳机制。最后说明了主从复制常见问题。<br>耗时俩天写的文章，这也是咔咔最近耗时最长的一篇文章，以后咔咔发的文章估计都是这样的，不会在把一问题单独出多篇文章来讲解，会一篇文章全部说完。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1>]]></content>
      <tags>
        <tag>面试题</tag>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
