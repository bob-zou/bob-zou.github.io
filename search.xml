<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang三色标记、混合写屏障GC模式图文全分析</title>
    <url>/2021/01/28/golang-gc/</url>
    <content><![CDATA[<blockquote>
<p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。</p>
<p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the world)，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，Golang进行了多次的迭代优化来解决这个问题。</p>
</blockquote>
<h2 id="内容提纲"><a href="#内容提纲" class="headerlink" title="内容提纲"></a>内容提纲</h2><ul>
<li>G0 V1.3之前的标记-清除(mark and sweep)算法</li>
<li>Go V1.3之前的标记-清扫(mark and sweep)的缺点</li>
<li>Go V1.5的三色并发标记法</li>
<li>Go V1.5的三色标记为什么需要STW</li>
<li>Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )</li>
<li>Go V1.8混合写屏障机制</li>
<li>Go V1.8混合写屏障机制的全场景分析</li>
</ul>
<h2 id="一、Go-V1-3之前的标记-清除-mark-and-sweep-算法"><a href="#一、Go-V1-3之前的标记-清除-mark-and-sweep-算法" class="headerlink" title="一、Go V1.3之前的标记-清除(mark and sweep)算法"></a>一、Go V1.3之前的标记-清除(mark and sweep)算法</h2><p>此算法主要有两个主要的步骤：</p>
<ul>
<li>标记(Mark phase)</li>
<li>清除(Sweep phase)</li>
</ul>
<p><strong>第一步</strong> 暂停程序业务逻辑<br>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停，即<code>STW(stop the world)</code>。<br>也就是说，这段时间程序会卡在那儿。<br><img src="mas-1.png" alt="setp-1"></p>
<p><strong>第二步</strong> 开始标记，程序找出它所有可达的对象，并做上标记<br><img src="mas-2.png" alt="setp-2"></p>
<p><strong>第三步</strong> 标记完了之后，然后开始清除未标记的对象<br><img src="mas-3.png" alt="setp-3"></p>
<p><strong>第四步</strong> 停止暂停，让程序继续跑。<br>然后循环重复这个过程，直到process程序生命周期结束。</p>
<h2 id="二、标记-清扫-mark-and-sweep-的缺点"><a href="#二、标记-清扫-mark-and-sweep-的缺点" class="headerlink" title="二、标记-清扫(mark and sweep)的缺点"></a>二、标记-清扫(mark and sweep)的缺点</h2><ul>
<li><code>STW(stop the world)</code> 让程序暂停，程序出现卡顿 (<code>重要问题</code>)。</li>
<li>标记需要扫描整个heap</li>
<li>清除数据会产生heap碎片</li>
</ul>
<p>Go V1.3版本之前就是以上来实施的, 流程是<br><img src="mas-4.png" alt="before v1.3"></p>
<p>Go V1.3 做了简单的优化,将STW提前, 减少STW暂停的时间范围<br><img src="mas-5.png" alt="v1.3"></p>
<p><strong>这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序</strong></p>
<p>Go是如何面对并这个问题的呢？接下来Go V1.5版本 就用<code>三色并发标记法</code>来优化这个问题.</p>
<h2 id="三、Go-V1-5的三色并发标记法"><a href="#三、Go-V1-5的三色并发标记法" class="headerlink" title="三、Go V1.5的三色并发标记法"></a>三、Go V1.5的三色并发标记法</h2><p>三色标记法 实际上就是通过三个阶段的标记来确定清楚的对象都有哪些. 我们来看一下具体的过程.</p>
<p><strong>第一步</strong> 就是只要是新创建的对象, 默认的颜色都是标记为<code>白色</code>.<br><img src="tri-color-1.png" alt="setp-1-1"><br>这里面需要注意的是, 所谓<code>程序</code>, 则是一些对象的根节点集合.<br>所以上图,可以转换如下的方式来表示.<br><img src="tri-color-2.png" alt="setp-1-2"></p>
<p><strong>第二步</strong> 每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从<code>白色</code>集合放入<code>灰色</code>集合。<br><img src="tri-color-3.png" alt="setp-2-1"></p>
<p><strong>第三步</strong> 遍历<code>灰色</code>集合，将<code>灰色</code>对象引用的对象从<code>白色</code>集合放入<code>灰色</code>集合，之后将此<code>灰色</code>对象放入<code>黑色</code>集合<br><img src="tri-color-4.png" alt="setp-3-1"></p>
<p><strong>第四步</strong> 重复第三步, 直到<code>灰色</code>中无任何对象.<br><img src="tri-color-5.png" alt="setp-4-1"><br><img src="tri-color-6.png" alt="setp-4-2"></p>
<p><strong>第五步</strong> 回收所有的<code>白色</code>标记表的对象. 也就是回收垃圾.<br><img src="tri-color-7.png" alt="setp-5-1"></p>
<p>以上便是<code>三色并发标记法</code>, 不难看出,我们上面已经清楚的体现<code>三色</code>的特性, 那么又是如何实现<code>并行</code>的呢?<br>同时又是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p>
<h2 id="四、没有STW的三色标记法"><a href="#四、没有STW的三色标记法" class="headerlink" title="四、没有STW的三色标记法"></a>四、没有STW的三色标记法</h2><p>我们还是基于上述的<code>三色并发标记法</code>来说, 他是一定要依赖<code>STW</code>的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。</p>
<p>我们举一个场景, 如果<code>三色标记法</code>, 标记过程不使用<code>STW</code>将会发生什么事情?<br><img src="tri-no-stw-1.png" alt="tri-no-stw"><br><img src="tri-no-stw-2.png" alt="tri-no-stw"><br><img src="tri-no-stw-3.png" alt="tri-no-stw"><br><img src="tri-no-stw-4.png" alt="tri-no-stw"><br><img src="tri-no-stw-5.png" alt="tri-no-stw"></p>
<p>可以看出，有两个问题, 在三色标记法中,是不希望被发生的</p>
<ul>
<li>条件1: 一个<code>白色</code>对象被<code>黑色</code>对象引用(<strong><code>白色</code>被挂在<code>黑色</code>下</strong>)</li>
<li>条件2: <code>灰色</code>对象与它之间的可达关系的<code>白色</code>对象遭到破坏(<strong><code>灰色</code>同时丢了该<code>白色</code></strong>)<br>当以上两个条件同时满足时, 就会出现对象丢失现象!</li>
</ul>
<p>当然, 如果上述中的白色对象3, 如果他还有很多下游对象的话, 也会一并都清理掉!</p>
<p>为了防止这种现象的发生，最简单的方式就是<code>STW</code>，直接禁止掉其他用户程序对对象引用关系的干扰，<strong>但是<code>STW</code>的过程有明显的资源浪费，对所有的用户程序都有很大影响</strong>，如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少<code>STW</code>时间呢？</p>
<h2 id="五、屏障机制"><a href="#五、屏障机制" class="headerlink" title="五、屏障机制"></a>五、屏障机制</h2><p>我们让GC回收器,满足下面两种情况之一时,可保对象不丢失,所以引出两种方式.</p>
<h3 id="强-弱-三色不变式"><a href="#强-弱-三色不变式" class="headerlink" title="强-弱 三色不变式"></a>强-弱 三色不变式</h3><h4 id="强三色不变式-不存在黑色对象引用到白色对象的指针"><a href="#强三色不变式-不存在黑色对象引用到白色对象的指针" class="headerlink" title="强三色不变式 - 不存在黑色对象引用到白色对象的指针"></a>强三色不变式 - 不存在黑色对象引用到白色对象的指针</h4><p><img src="sw-1.png" alt="sw-1"></p>
<h4 id="弱三色不变式-所有被黑色对象引用的白色对象都处于灰色保护状态"><a href="#弱三色不变式-所有被黑色对象引用的白色对象都处于灰色保护状态" class="headerlink" title="弱三色不变式 - 所有被黑色对象引用的白色对象都处于灰色保护状态"></a>弱三色不变式 - 所有被黑色对象引用的白色对象都处于灰色保护状态</h4><p><img src="sw-2.png" alt="sw-2"></p>
<p>为了遵循上述的两个方式,Golang团队初步得到了两种屏障方式<code>插入屏障</code>和<code>删除屏障</code></p>
<h3 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h3><p><strong>具体操作</strong>: 在<code>A对象</code>引用<code>B对象</code>的时候，<code>B对象</code>被标记为灰色。(将B挂在A下游，B必须被标记为<code>灰色</code>)<br><strong>满足</strong>: <strong>强三色不变式</strong>. (不存在<code>黑色</code>对象引用<code>白色</code>对象的情况了， 因为<code>白色</code>会强制变成<code>灰色</code>)</p>
<p>伪码如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) {   </span><br><span class="line">  //1</span><br><span class="line">  标记灰色(新下游对象ptr)   </span><br><span class="line">  </span><br><span class="line">  //2</span><br><span class="line">  当前下游对象slot = 新下游对象ptr                    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>两种场景：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色</span><br><span class="line">A.添加下游对象(C, B)     //A 将下游对象C 更换为B，  B被标记为灰色</span><br></pre></td></tr></tbody></table></figure>
<p>这段伪码逻辑就是写屏障.<br>我们知道,<code>黑色</code>对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>.<br><code>栈</code>空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用,所以<code>插入屏障</code>机制,在<code>栈</code>空间的对象操作中不使用.<br>而仅仅使用在<code>堆</code>空间对象的操作中.</p>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。<br><img src="sw-3.png" alt="sw-3"><br><img src="sw-4.png" alt="sw-4"><br><img src="sw-5.png" alt="sw-5"><br><img src="sw-6.png" alt="sw-6"><br><img src="sw-7.png" alt="sw-7"><br><img src="sw-8.png" alt="sw-8"><br>但是如果<code>栈</code>不添加,当全部三色标记扫描之后,<code>栈</code>上有可能依然存在<code>白色</code>对象被引用的情况(如上图的<code>对象9</code>).<br>所以要对<code>栈</code>重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动<code>STW</code>暂停.<br>直到栈空间的三色标记结束.<br><img src="sw-9.png" alt="sw-9"><br><img src="sw-10.png" alt="sw-10"><br><img src="sw-11.png" alt="sw-11"><br>最后将<code>栈</code>和<code>堆</code>空间扫描剩余的全部<code>白色</code>节点清除. 这次<code>STW</code>大约的时间在<code>10~100ms</code>间.<br><img src="sw-12.png" alt="sw-12"></p>
<h3 id="删除屏蔽"><a href="#删除屏蔽" class="headerlink" title="删除屏蔽"></a>删除屏蔽</h3><p><strong>具体操作</strong>: 被删除的对象，如果自身为<code>灰色</code>或者<code>白色</code>，那么被标记为<code>灰色</code>。<br><strong>满足</strong>: <strong>弱三色不变式</strong>. (保护<code>灰色</code>对象到<code>白色</code>对象的路径不会断)</p>
<p>伪代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot， 新下游对象ptr) {</span><br><span class="line">  //1</span><br><span class="line">  if (当前对象是灰色 || 当前对象是白色) {</span><br><span class="line">      标记灰色(当前下游对象slot)     //slot为被删除对象， 标记为灰色</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  //2</span><br><span class="line">  当前下游对象slot = 新下游对象ptr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>两种场景：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">A.添加下游对象(B, nil)   //A对象，删除B对象的引用  B被A删除，被标记为灰(如果A为灰度或者A为白色)</span><br><span class="line">A.添加下游对象(B, C)     //A对象，更换下游B变成C   B被A删除，被标记为灰(如果A为灰度或者A为白色)</span><br></pre></td></tr></tbody></table></figure>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。<br><img src="sw-13.png" alt="sw-13"><br><img src="sw-14.png" alt="sw-14"><br><img src="sw-15.png" alt="sw-15"><br><img src="sw-16.png" alt="sw-16"><br><img src="sw-17.png" alt="sw-17"><br><img src="sw-18.png" alt="sw-18"><br><img src="sw-19.png" alt="sw-19"></p>
<p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p>
<h2 id="六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制"><a href="#六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制" class="headerlink" title="六、Go V1.8的混合写屏障(hybrid write barrier)机制"></a>六、Go V1.8的混合写屏障(hybrid write barrier)机制</h2><p>插入写屏障和删除写屏障的短板：</p>
<ul>
<li>插入写屏障：结束时需要<code>STW</code>来重新扫描栈，标记栈上引用的<code>白色</code>对象的存活；</li>
<li>删除写屏障：回收精度低，GC开始时<code>STW</code>扫描<code>堆栈</code>来记录初始快照，这个过程会保护开始时刻的所有存活对象。<br>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了<code>STW</code>的时间。结合了两者的优点。</li>
</ul>
<h3 id="混合写屏障规则"><a href="#混合写屏障规则" class="headerlink" title="混合写屏障规则"></a>混合写屏障规则</h3><p><strong>具体操作</strong>:</p>
<ul>
<li>GC开始将<code>栈</code>上的对象全部扫描并标记为<code>黑色</code>(之后不再进行第二次重复扫描，无需<code>STW</code>)，</li>
<li>GC期间，任何在栈上创建的新对象，均为<code>黑色</code>。</li>
<li>被删除的对象标记为<code>灰色</code>。</li>
<li>被添加的对象标记为<code>灰色</code>。</li>
</ul>
<p><strong>满足</strong>: <strong>变形的弱三色不变式</strong></p>
<p><strong>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率</strong></p>
<p>伪代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) {</span><br><span class="line">    //1 </span><br><span class="line">    标记灰色(当前下游对象slot)    //只要当前下游对象被移走，就标记灰色</span><br><span class="line">      </span><br><span class="line">    //2 </span><br><span class="line">    标记灰色(新下游对象ptr)</span><br><span class="line">          </span><br><span class="line">    //3</span><br><span class="line">    当前下游对象slot = 新下游对象ptr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="混合写屏障的具体场景分析"><a href="#混合写屏障的具体场景分析" class="headerlink" title="混合写屏障的具体场景分析"></a>混合写屏障的具体场景分析</h3><p>注意<code>混合写屏障</code>是<code>GC</code>的一种屏障机制，所以只是当程序执行<code>GC</code>的时候，才会触发这种机制。<br>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<p><strong>GC开始：扫描栈区，将可达对象全部标记为黑</strong><br><img src="hwb-1.png" alt="hwb-1"><br><img src="hwb-2.png" alt="hwb-2"></p>
<p><strong>场景一</strong><br>对象被一个<code>堆</code>对象删除引用，成为<code>栈</code>对象的下游<br>伪代码:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//前提：堆对象4-&gt;对象7 = 对象7；  //对象7 被 对象4引用</span><br><span class="line">栈对象1-&gt;对象7 = 堆对象7；  //将堆对象7 挂在 栈对象1 下游</span><br><span class="line">堆对象4-&gt;对象7 = null；    //对象4 删除引用 对象7</span><br></pre></td></tr></tbody></table></figure>
<p><img src="hwb-3.png" alt="hwb-3"><br><img src="hwb-4.png" alt="hwb-4"></p>
<p><strong>场景二</strong><br>对象被一个<code>栈</code>对象删除引用，成为另一个<code>栈</code>对象的下游<br>伪代码:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">new 栈对象9；</span><br><span class="line">对象8-&gt;对象3 = 对象3；      //将栈对象3 挂在 栈对象9 下游</span><br><span class="line">对象2-&gt;对象3 = null；      //对象2 删除引用 对象3</span><br></pre></td></tr></tbody></table></figure>
<p><img src="hwb-5.png" alt="hwb-5"><br><img src="hwb-6.png" alt="hwb-6"><br><img src="hwb-7.png" alt="hwb-7"></p>
<p><strong>场景三</strong><br>对象被一个<code>堆</code>对象删除引用，成为另一个<code>堆</code>对象的下游<br>伪代码:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">堆对象10-&gt;对象7 = 堆对象7；       //将堆对象7 挂在 堆对象10 下游</span><br><span class="line">堆对象4-&gt;对象7 = null；         //对象4 删除引用 对象7</span><br></pre></td></tr></tbody></table></figure>
<p><img src="hwb-8.png" alt="hwb-8"><br><img src="hwb-9.png" alt="hwb-9"><br><img src="hwb-10.png" alt="hwb-10"></p>
<p><strong>场景四</strong><br>对象从一个<code>栈</code>对象删除引用，成为另一个<code>堆</code>对象的下游<br>伪代码:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">堆对象10-&gt;对象7 = 堆对象7；       //将堆对象7 挂在 堆对象10 下游</span><br><span class="line">堆对象4-&gt;对象7 = null；         //对象4 删除引用 对象7</span><br></pre></td></tr></tbody></table></figure>
<p><img src="hwb-11.png" alt="hwb-11"><br><img src="hwb-12.png" alt="hwb-12"><br><img src="hwb-13.png" alt="hwb-13"></p>
<p>Golang中的<code>混合写屏障</code>满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的<code>栈</code>，使其变<code>黑</code>并一直保持，这个过程不需要<code>STW</code>，而标记结束后，因为<code>栈</code>在扫描后始终是<code>黑色</code>的，也无需再进行re-scan操作了，减少了<code>STW</code>的时间。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。</p>
<p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。<br>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通<br>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>
<p>参考文献:</p>
<ul>
<li><a href="https://www.cnblogs.com/wangyiyang/p/12191591.html">https://www.cnblogs.com/wangyiyang/p/12191591.html</a></li>
<li><a href="https://www.jianshu.com/p/eb6b3aff9ca5">https://www.jianshu.com/p/eb6b3aff9ca5</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/74853110">https://zhuanlan.zhihu.com/p/74853110</a></li>
</ul>
<h2 id="相关好博客推荐"><a href="#相关好博客推荐" class="headerlink" title="相关好博客推荐"></a>相关好博客推荐</h2><ul>
<li><a href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html">Garbage Collection In Go : Part I - Semantics</a></li>
<li><a href="https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html">Garbage Collection In Go : Part II - GC Traces</a></li>
<li><a href="https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html">Garbage Collection In Go : Part III - GC Pacing</a></li>
</ul>
<p><strong>原文作者:</strong> <a href="https://segmentfault.com/u/aceld">刘丹冰 Aceld</a><br><strong>原文地址:</strong> <a href="https://segmentfault.com/a/1190000022030353">Golang三色标记、混合写屏障GC模式图文全分析</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>gc</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程的虚拟内存</title>
    <url>/2021/01/31/linux-process-vm/</url>
    <content><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2>]]></content>
      <tags>
        <tag>虚拟内存</tag>
        <tag>linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang调度器GMP原理与调度全分析</title>
    <url>/2021/01/29/golang-gmp/</url>
    <content><![CDATA[<blockquote>
<p>该文章主要详细具体的介绍Goroutine调度器过程及原理，可以对Go调度器的详细调度过程有一个清晰的理解。</p>
</blockquote>
<h2 id="内容提纲"><a href="#内容提纲" class="headerlink" title="内容提纲"></a>内容提纲</h2><ul>
<li>Golang调度器的由来</li>
<li>Goroutine调度器的GMP模型及设计思想</li>
<li>Goroutine调度场景过程全图文解析</li>
</ul>
<h2 id="一、Golang调度器的由来？"><a href="#一、Golang调度器的由来？" class="headerlink" title="一、Golang调度器的由来？"></a>一、Golang调度器的由来？</h2><h3 id="单进程时代不需要调度器"><a href="#单进程时代不需要调度器" class="headerlink" title="单进程时代不需要调度器"></a>单进程时代不需要调度器</h3><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。<br>早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是<code>单进程时代</code>, 一切的程序只能串行发生。<br><img src="sproc-1.png" alt="sproc-1"></p>
<p>早期的单进程操作系统，面临2个问题：</p>
<ul>
<li>单一的执行流程，计算机只能一个任务一个任务的处理</li>
<li>进程阻塞所带来的CPU时间浪费<br>那么能不能有多个进程来宏观一起来执行多个任务呢？<br>后来操作系统就具有了最早的并发能力： <strong>多进程并发</strong><br>当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</li>
</ul>
<h3 id="多进程-线程时代有了调度器需求"><a href="#多进程-线程时代有了调度器需求" class="headerlink" title="多进程/线程时代有了调度器需求"></a>多进程/线程时代有了调度器需求</h3><p><img src="mproc-1.png" alt="mproc-1"><br>在多进程/多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞CPU可以立刻切换到其他进程中去执行，而且调度CPU的算法可以保证在运行的进程都可以被分配到CPU的运行时间片。<br>这样从宏观来看，似乎多个进程是在同时被运行。<br>但新的问题就又出现了，进程拥有太多的资源，进程的<strong>创建</strong>、<strong>切换</strong>、<strong>销毁</strong>，都会占用很长的时间。<br>CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。</p>
<p><strong>怎么才能提高CPU的利用率呢？</strong><br><img src="mproc-2.png" alt="mproc-2"><br>很明显，CPU调度切换的是进程和线程。<br>尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p>
<h3 id="协程来提高CPU利用率"><a href="#协程来提高CPU利用率" class="headerlink" title="协程来提高CPU利用率"></a>协程来提高CPU利用率</h3><p>多进程、多线程已经提高了系统的并发能力。<br>但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(<a href="https://blog.zouyapeng.com/2021/01/31/linux-process-vm/">进程虚拟内存</a> 会占用<strong>4GB</strong>[32位操作系统], 而线程也要大约<strong>4MB</strong>)。<br>大量的进程/线程出现了新的问题：</p>
<ul>
<li>高内存占用</li>
<li>调度的高消耗CPU<br>之后，攻城狮们就发现，其实一个线程分为<code>内核态线程</code>和<code>用户态线程</code>。<br>一个<code>用户态线程</code>必须要绑定一个<code>内核态线程</code></li>
</ul>
<p>但是CPU并不知道有<code>用户态线程</code>的存在，它只知道它运行的是一个<code>内核态线程</code>(Linux的PCB进程控制块)。<br><img src="co-routine-1.png" alt="co-routine-1"><br>这样，我们再去细化去分类一下，内核线程依然叫<code>线程(thread)</code>，用户线程叫<code>协程(co-routine)</code>.<br><img src="co-routine-2.png" alt="co-routine-2"><br>看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。<br>之后，我们就看到了有3种协程和线程的映射关系</p>
<h4 id="N-1-关系-N个协程绑定1个线程"><a href="#N-1-关系-N个协程绑定1个线程" class="headerlink" title="N:1 关系(N个协程绑定1个线程)"></a>N:1 关系(N个协程绑定1个线程)</h4><p>优点:</p>
<ul>
<li>协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。<br>缺点：</li>
<li>一个进程的所有协程都绑定在一个线程上。</li>
<li>某个程序用不了硬件的多核加速能力。</li>
<li>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。<br><img src="co-routine-3.png" alt="co-routine-3"></li>
</ul>
<h4 id="1-1-关系-1个协程绑定1个线程"><a href="#1-1-关系-1个协程绑定1个线程" class="headerlink" title="1:1 关系(1个协程绑定1个线程)"></a>1:1 关系(1个协程绑定1个线程)</h4><p>优点: 简单易于实现<br>缺点: </p>
<ul>
<li>协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。<br><img src="co-routine-4.png" alt="co-routine-4"></li>
</ul>
<h4 id="M-N关系-M个协程绑定1个线程-是N-1和1-1类型的结合-但是难以实现"><a href="#M-N关系-M个协程绑定1个线程-是N-1和1-1类型的结合-但是难以实现" class="headerlink" title="M:N关系(M个协程绑定1个线程, 是N:1和1:1类型的结合, 但是难以实现)"></a>M:N关系(M个协程绑定1个线程, 是N:1和1:1类型的结合, 但是难以实现)</h4><p><img src="co-routine-5.png" alt="co-routine-5"><br>协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。</p>
<h3 id="Go语言的协程-goroutine"><a href="#Go语言的协程-goroutine" class="headerlink" title="Go语言的协程(goroutine)"></a>Go语言的协程(goroutine)</h3><p>Go为了提供更容易使用的并发方法，使用了<code>goroutine</code>和<code>channel</code>。<br>goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。<br>最关键的是，<strong>程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发</strong>。<br>Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。<br>虽然一个goroutine的栈只占几KB，但实际是<strong>可伸缩的</strong>，如果需要更多内容，<code>runtime</code>会自动为goroutine分配。<br>Goroutine特点：</p>
<ul>
<li>占用内存更小（几kb）</li>
<li>调度更灵活(<code>runtime</code>调度)</li>
</ul>
<h3 id="被废弃的goroutine调度器"><a href="#被废弃的goroutine调度器" class="headerlink" title="被废弃的goroutine调度器"></a>被废弃的goroutine调度器</h3><p>既然我们知道了<code>协程</code>和<code>线程</code>的关系，那么最关键的一点就是调度协程的调度器的实现了。<br>Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了。<br>那么我们先来分析一下被废弃的调度器是如何运作的？</p>
<p>大部分文章都是会用<code>G</code>来表示Goroutine，用<code>M</code>来表示线程(OS Thread)，那么我们也会用这种表达的对应关系。<br><img src="go-schd-old-1.png" alt="go-schd-old-1"><br>下面我们来看看被废弃的golang调度器是如何实现的<br><img src="go-schd-old-2.png" alt="go-schd-old-2"><br><code>M</code>想要执行、放回<code>G</code>都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局<code>G</code>队列是有互斥锁进行保护的。<br>老调度器有几个缺点：</p>
<ul>
<li>创建、销毁、调度<code>G</code>都需要每个<code>M</code>获取锁，这就形成了激烈的锁竞争。</li>
<li><code>M</code>转移<code>G</code>会造成延迟和额外的系统负载。比如当<code>G</code>中包含创建新协程的时候，<code>M</code>创建了<code>G2</code>，为了继续执行<code>G</code>，需要把<code>G2</code>交给<code>M2</code>执行，也造成了很差的局部性，因为<code>G2</code>和<code>G</code>是相关的，最好放在<code>M</code>上执行，而不是<code>M2</code>上。</li>
<li>系统调用(CPU在<code>M</code>之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ul>
<h2 id="二、Goroutine调度器的GMP模型的设计思想"><a href="#二、Goroutine调度器的GMP模型的设计思想" class="headerlink" title="二、Goroutine调度器的GMP模型的设计思想"></a>二、Goroutine调度器的GMP模型的设计思想</h2><p>面对之前调度器的问题，Go设计了新的调度器。<br>在新调度器中，出列M(thread)和G(goroutine)，又引入了P(Processor)。<br><img src="go-schd-1.png" alt="go-schd-1.png"><br><strong>Processor包含了运行goroutine的资源</strong>，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p>
<h3 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h3><p>在Go中，<strong>线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上</strong>。<br><img src="go-schd-2.png" alt="go-schd-2.png"><br><strong>全局队列（Global Queue）</strong>：存放等待运行的G。<br><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过<strong>256</strong>个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。<br><strong>P列表</strong>：所有的P都在程序启动时创建，并保存在数组中，最多有<code>GOMAXPROCS</code>(可配置)个。<br><strong>M</strong>：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。<br>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行。</p>
<p><strong>P和M的个数问题</strong></p>
<ul>
<li>P的数量<ul>
<li>由启动时环境变量<code>GOMAXPROCS</code>或者是由<code>runtime</code>的方法<code>GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有<code>GOMAXPROCS</code>个goroutine在同时运行。</li>
</ul>
</li>
<li>M的数量<ul>
<li>go语言本身的限制：go程序启动时，会设置M的最大数量，默认<strong>10000</strong>。但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li>
<li><code>runtime/debug</code>中的<code>SetMaxThreads</code>函数，设置<code>M</code>的最大数量</li>
<li>一个<code>M</code>阻塞了，会创建新的<code>M</code><br><code>M</code>与<code>P</code>的数量没有绝对关系，一个<code>M</code>阻塞，<code>P</code>就会去创建或者切换另一个<code>M</code>，所以，即使<code>P</code>的默认数量是<strong>1</strong>，也有可能会创建很多个<code>M</code>出来。</li>
</ul>
</li>
</ul>
<p><strong>P和M何时会被创建</strong></p>
<ul>
<li><strong>P</strong>，在确定了<code>P</code>的最大数量n后，运行时系统会根据这个数量创建n个<code>P</code>。</li>
<li><strong>M</strong>，没有足够的<code>M</code>来关联<code>P</code>并运行其中的可运行的<code>G</code>。比如所有的<code>M</code>此时都阻塞住了，而<code>P</code>中还有很多就绪任务，就会去寻找空闲的<code>M</code>，而没有空闲的，就会去创建新的<code>M</code>。</li>
</ul>
<h3 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h3><ul>
<li><strong>复用线程</strong>(避免频繁的创建、销毁线程，而是对线程的复用)<ul>
<li><strong>work stealing机制</strong>，当本线程无可运行的<code>G</code>时，尝试从其他线程绑定的<code>P</code>偷取<code>G</code>，而不是销毁线程。</li>
<li><strong>hand off机制</strong>，当本线程因为<code>G</code>进行系统调用阻塞时，线程释放绑定的<code>P</code>，把<code>P</code>转移给其他空闲的线程执行。</li>
</ul>
</li>
<li><strong>利用并行</strong><ul>
<li><code>GOMAXPROCS</code>设置<code>P</code>的数量，最多有<code>GOMAXPROCS</code>个线程分布在多个CPU上同时运行。</li>
<li><code>GOMAXPROCS</code>也限制了并发的程度，比如<code>GOMAXPROCS</code> = 核数/2，则最多利用了一半的CPU核进行并行。</li>
</ul>
</li>
<li><strong>抢占</strong><ul>
<li>在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</li>
</ul>
</li>
<li><strong>全局G队列</strong><ul>
<li>在新的调度器中依然有全局<code>G</code>队列，但功能已经被弱化了，当<code>M</code>执行work stealing从其他<code>P</code>偷不到<code>G</code>时，它可以从全局<code>G</code>队列获取<code>G</code>。</li>
</ul>
</li>
</ul>
<h3 id="go-func-调度流程"><a href="#go-func-调度流程" class="headerlink" title="go func() 调度流程"></a>go func() 调度流程</h3><p><img src="go-schd-3.png" alt="go-schd-3.png"><br>从上图我们可以分析出几个结论：</p>
<ol>
<li>我们通过 <code>go func()</code>来创建一个goroutine；</li>
<li>有两个存储<code>G</code>的队列，一个是局部调度器<code>P</code>的本地队列、一个是全局<code>G</code>队列。新创建的<code>G</code>会先保存在<code>P</code>的本地队列中，如果<code>P</code>的本地队列已经满了就会保存在全局的队列中；</li>
<li><code>G</code>只能运行在<code>M</code>中，一个<code>M</code>必须持有一个<code>P</code>，<code>M</code>与<code>P</code>是1：1的关系。<code>M</code>会从<code>P</code>的本地队列弹出一个可执行状态的<code>G</code>来执行，如果<code>P</code>的本地队列为空，就会想其他的<code>MP</code>组合偷取一个可执行的<code>G</code>来执行； </li>
<li>一个<code>M</code>调度<code>G</code>执行的过程是一个循环机制；</li>
<li>当<code>M</code>执行某一个<code>G</code>时候如果发生了<code>syscall</code>或则其余阻塞操作，<code>M</code>会阻塞，如果当前有一些<code>G</code>在执行，<code>runtime</code>会把这个线程<code>M</code>从<code>P</code>中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个<code>P</code>； </li>
<li>当<code>M</code>系统调用结束时候，这个<code>G</code>会尝试获取一个空闲的<code>P</code>执行，并放入到这个<code>P</code>的本地队列。如果获取不到<code>P</code>，那么这个线程<code>M</code>变成休眠状态， 加入到空闲线程中，然后这个<code>G</code>会被放入全局队列中。</li>
</ol>
<h3 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h3><p><img src="go-schd-4.png" alt="go-schd-4.png"><br><strong>M0</strong><br><code>M0</code>是启动程序后的编号为0的主线程，这个<code>M</code>对应的实例会在全局变量<code>runtime.m0</code>中，不需要在heap上分配，<code>M0</code>负责执行初始化操作和启动第一个<code>G</code>， 在之后<code>M0</code>就和其他的<code>M</code>一样了。<br><strong>G0</strong><br><code>G0</code>是每次启动一个<code>M</code>都会第一个创建的gourtine，<code>G0</code>仅用于负责调度的<code>G</code>，<code>G0</code>不指向任何可执行的函数, 每个<code>M</code>都会有一个自己的<code>G0</code>。在调度或系统调用时会使用<code>G0</code>的栈空间, 全局变量的<code>G0</code>是<code>M0</code>的<code>G0</code>。</p>
<p>我们来跟踪一段代码</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"Hello world"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>接下来我们来针对上面的代码对调度器里面的结构做一个分析, 也会经历如上图所示的过程：</p>
<ol>
<li><code>runtime</code>创建最初的线程<code>M0</code>和<code>G0</code>，并把两者关联。</li>
<li>调度器初始化：初始化<code>M0</code>、栈、垃圾回收，以及创建和初始化由<code>GOMAXPROCS</code>个<code>P</code>构成的<code>P</code>列表。</li>
<li>示例代码中的<code>main</code>函数是<code>main.main</code>，<code>runtime</code>中也有个<code>main</code>函数(<code>runtime.main</code>)，代码经过编译后，<code>runtime.main</code>会调用<code>main.main</code>，程序启动时会为<code>runtime.main</code>创建goroutine，称它为main goroutine吧，然后把main goroutine加入到<code>P</code>的本地队列。</li>
<li>启动<code>M0</code>，<code>M0</code>已经绑定了<code>P</code>，会从<code>P</code>的本地队列获取<code>G</code>，获取到main goroutine。</li>
<li><code>G</code>拥有栈，<code>M</code>根据<code>G</code>中的栈信息和调度信息设置运行环境</li>
<li><code>M</code>运行<code>G</code></li>
<li><code>G</code>退出，再次回到<code>M</code>获取可运行的<code>G</code>，这样重复下去，直到<code>main.main</code>退出，<code>runtime.main</code>执行Defer和Panic处理，或调用<code>runtime.exit</code>退出程序。<br>调度器的生命周期几乎占满了一个GO程序的一生，<code>runtime.main</code>的goroutine执行之前都是为调度器做准备工作，<code>runtime.main</code>的goroutine运行，才是调度器的真正开始，直到<code>runtime.main</code>结束而结束。</li>
</ol>
<h3 id="可视化GMP编程"><a href="#可视化GMP编程" class="headerlink" title="可视化GMP编程"></a>可视化GMP编程</h3><p>有2种方式可以查看一个程序的GMP的数据</p>
<h4 id="方式1：go-tool-trace"><a href="#方式1：go-tool-trace" class="headerlink" title="方式1：go tool trace"></a>方式1：go tool trace</h4><p>trace记录了运行时的信息，能提供可视化的Web页面。<br>简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印”Hello World”退出。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime/trace"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建trace文件</span></span><br><span class="line">    f, err := os.Create(<span class="string">"trace.out"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动trace goroutine</span></span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行程序</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ go run trace.go </span><br><span class="line">Hello World</span><br></pre></td></tr></tbody></table></figure>
<p>会得到一个trace.out文件，然后我们可以用一个工具打开，来分析这个文件。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ go tool trace trace.out </span><br><span class="line">2020/02/23 10:44:11 Parsing trace...</span><br><span class="line">2020/02/23 10:44:11 Splitting trace...</span><br><span class="line">2020/02/23 10:44:11 Opening browser. Trace viewer is listening on http://127.0.0.1:33479</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以通过浏览器打开<a href="http://127.0.0.1:33479网址，点击view">http://127.0.0.1:33479网址，点击view</a> trace 能够看见可视化的调度流程。<br><img src="trace-1.png" alt="trace-1"><br><img src="trace-2.png" alt="trace-2"></p>
<p><strong>G信息</strong>：点击Goroutines那一行可视化的数据条，我们会看到一些详细的信息。<br><img src="trace-3.png" alt="trace-3"><br><em>一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论</em><br>其中G1应该就是main goroutine(执行main函数的协程)，在一段时间内处于可运行和运行的状态。</p>
<p><strong>M信息</strong>：点击Threads那一行可视化的数据条，我们会看到一些详细的信息。<br><img src="trace-4.png" alt="trace-4"><br><em>一共有两个M在程序中，一个是特殊的M0，用于初始化使用，这个我们不必讨论</em><br><img src="trace-5.png" alt="trace-5"><br>G1中调用了main.main，创建了trace goroutine G18。G1运行在P1上，G18运行在P0上。<br>这里有两个P，我们知道，一个P必须绑定一个M才能调度G。<br>我们在来看看上面的M信息。<br><img src="trace-6.png" alt="trace-6"><br>我们会发现，确实G18在P0上被运行的时候，确实在Threads行多了一个M的数据，点击查看如下：<br><img src="trace-7.png" alt="trace-7"><br>多了一个M2应该就是P0为了执行G18而动态创建的M2.</p>
<h4 id="方式2：Debug-trace"><a href="#方式2：Debug-trace" class="headerlink" title="方式2：Debug trace"></a>方式2：Debug trace</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ go build trace2.go</span><br></pre></td></tr></tbody></table></figure>
<p>通过Debug方式运行</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ GODEBUG=schedtrace=1000 ./trace2 </span><br><span class="line">SCHED 0ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1 idlethreads=1 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 1003ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 2014ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 3015ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 4023ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br></pre></td></tr></tbody></table></figure>
<p><code>SCHED</code>：调试信息输出标志字符串，代表本行是goroutine调度器的输出；<br><code>0ms</code>：即从程序启动到输出这行日志的时间；<br><code>gomaxprocs</code>: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；<br><code>idleprocs</code>: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；<br><code>threads</code>: os threads/M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；<br><code>spinningthreads</code>: 处于自旋状态的os thread数量；<br><code>idlethread</code>: 处于idle状态的os thread的数量；<br><code>runqueue=0</code>： Scheduler全局队列中G的数量；<br><code>[0 0]</code>: 分别为2个P的local queue中的G的数量。</p>
<h2 id="三、Go调度器调度场景过程全解析"><a href="#三、Go调度器调度场景过程全解析" class="headerlink" title="三、Go调度器调度场景过程全解析"></a>三、Go调度器调度场景过程全解析</h2><h3 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h3><p>P拥有G1，M1获取P后开始运行G1，G1使用go func()创建了G2，为了局部性G2优先加入到P1的本地队列。<br><img src="scene-1.png" alt="scene-1"></p>
<h3 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h3><p>G1运行完成后(函数：<code>goexit</code>)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：<code>schedule</code>）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：<code>execute</code>)。实现了线程M1的复用。<br><img src="scene-2.png" alt="scene-2"></p>
<h3 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h3><p>假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入P1的本地队列，P1本地队列满了。<br><img src="scene-3.png" alt="scene-3"></p>
<h3 id="场景4"><a href="#场景4" class="headerlink" title="场景4"></a>场景4</h3><p>G2在创建G7的时候，发现P1的本地队列已满，需要执行负载均衡(把P1中本地队列中前一半的G，还有新创建G转移到全局队列)<br><em>实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列</em><br><img src="scene-4.png" alt="scene-4"><br>这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。</p>
<h3 id="场景5"><a href="#场景5" class="headerlink" title="场景5"></a>场景5</h3><p>G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。<br><img src="scene-5.png" alt="scene-5"><br>G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。</p>
<h3 id="场景6"><a href="#场景6" class="headerlink" title="场景6"></a>场景6</h3><p>规定：在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行。<br><img src="scene-6.png" alt="scene-6"><br>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程（没有G但为运行状态的线程，不断寻找G）。</p>
<h3 id="场景7"><a href="#场景7" class="headerlink" title="场景7"></a>场景7</h3><p>M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：findrunnable()）。<br>M2从全局队列取的G数量符合下面的公式：<code>n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))</code><br>至少从全局队列取1个G，但每次不要从全局队列移动太多的G到P本地队列，给其他P留点。这是<strong>从全局队列到P本地队列的负载均衡</strong>。<br><img src="scene-7.png" alt="scene-7"><br>假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。</p>
<h3 id="场景8"><a href="#场景8" class="headerlink" title="场景8"></a>场景8</h3><p>假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。<br><img src="scene-8.png" alt="scene-8"><br>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。</p>
<h3 id="场景9"><a href="#场景9" class="headerlink" title="场景9"></a>场景9</h3><p>G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于自旋状态，它们不断寻找goroutine。<br><img src="scene-9.png" alt="scene-9"><br>为什么要让M3和M4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU。<br>为什么不销毁现场，来节约CPU资源。<br>因为创建和销毁CPU也会浪费时间，我们希望当有新goroutine创建时，立刻能有M运行它，如果销毁再新建就增加了时延，降低了效率。<br>当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有<code>GOMAXPROCS</code>个自旋的线程(当前例子中的<code>GOMAXPROCS</code>=4，所以一共4个P)，多余的没事做线程会让他们休眠。</p>
<h3 id="场景10"><a href="#场景10" class="headerlink" title="场景10"></a>场景10</h3><p>假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;=P, 大部分都是M在抢占需要运行的P)，<br>G8创建了G9，G8进行了阻塞的系统调用，M2和P2立即解绑，<br>P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。<br>本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。<br><img src="scene-10.png" alt="scene-10"></p>
<h3 id="场景11"><a href="#场景11" class="headerlink" title="场景11"></a>场景11</h3><p>G8创建了G9，假如G8进行了非阻塞系统调用。<br><img src="scene-11.png" alt="scene-11"><br>M2和P2会解绑，但M2会记住P2，然后G8和M2进入系统调用状态。<br>当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，<br>如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。<br><strong>Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发</strong>。</p>
<h2 id="相关好博客推荐"><a href="#相关好博客推荐" class="headerlink" title="相关好博客推荐"></a>相关好博客推荐</h2><ul>
<li><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">Scheduling In Go: Part I - OS Scheduler</a></li>
<li><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">Scheduling In Go : Part II - Go Scheduler</a></li>
<li><a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html">Scheduling In Go : Part III - Concurrency</a></li>
</ul>
<p><strong>原文作者:</strong> <a href="https://segmentfault.com/u/aceld">刘丹冰 Aceld</a><br><strong>原文地址:</strong> <a href="https://segmentfault.com/a/1190000021951119">Golang三色标记、混合写屏障GC模式图文全分析</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>面试题</tag>
        <tag>goroutine</tag>
        <tag>gmp</tag>
      </tags>
  </entry>
</search>
